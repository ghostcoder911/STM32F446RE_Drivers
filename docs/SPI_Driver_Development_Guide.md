# Complete Guide to SPI Driver Development

A comprehensive step-by-step guide to understanding and developing SPI drivers for STM32 microcontrollers.

---

## Table of Contents

1. [Introduction to SPI](#1-introduction-to-spi)
2. [SPI Fundamentals](#2-spi-fundamentals)
3. [SPI Communication Modes](#3-spi-communication-modes)
4. [Understanding SPI Registers](#4-understanding-spi-registers)
5. [Driver Architecture](#5-driver-architecture)
6. [Step 1: MCU Header File Setup](#6-step-1-mcu-header-file-setup)
7. [Step 2: SPI Driver Header File](#7-step-2-spi-driver-header-file)
8. [Step 3: SPI Driver Implementation](#8-step-3-spi-driver-implementation)
9. [Testing Your Driver](#9-testing-your-driver)
10. [Interrupt-Based SPI](#10-interrupt-based-spi)
11. [Best Practices](#11-best-practices)
12. [Troubleshooting Guide](#12-troubleshooting-guide)

---

## 1. Introduction to SPI

### What is SPI?

SPI (Serial Peripheral Interface) is a synchronous serial communication protocol used to communicate between microcontrollers and peripheral devices like sensors, displays, SD cards, and other ICs.

### Key Characteristics

| Feature | Description |
|---------|-------------|
| Type | Synchronous (uses clock signal) |
| Wires | 4 wires (can be reduced to 3) |
| Speed | Up to several MHz (faster than I2C) |
| Topology | Master-Slave |
| Full Duplex | Yes (simultaneous send and receive) |

### Why Learn SPI Driver Development?

- **Widely Used**: Most sensors and peripherals support SPI
- **High Speed**: Faster than I2C and UART
- **Simple Protocol**: No addressing, no acknowledgment complexity
- **Full Duplex**: Send and receive simultaneously

### SPI vs Other Protocols

```
┌─────────────┬──────────────┬──────────────┬──────────────┐
│  Feature    │     SPI      │     I2C      │    UART      │
├─────────────┼──────────────┼──────────────┼──────────────┤
│  Wires      │   4 (3 min)  │      2       │      2       │
│  Speed      │   Fast       │   Medium     │    Slow      │
│  Duplex     │   Full       │   Half       │    Full      │
│  Addressing │   No (CS)    │   Yes        │    No        │
│  Multi-Slave│   Yes (CS)   │   Yes (Addr) │    No        │
│  Complexity │   Low        │   Medium     │    Low       │
└─────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 2. SPI Fundamentals

### 2.1 SPI Signal Lines

SPI uses 4 signal lines for communication:

```
┌─────────────────────────────────────────────────────────────────┐
│                       SPI SIGNAL LINES                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   MASTER                                           SLAVE        │
│  ┌───────┐                                       ┌───────┐     │
│  │       │─────── MOSI (Master Out Slave In) ───→│       │     │
│  │       │                                       │       │     │
│  │       │←────── MISO (Master In Slave Out) ────│       │     │
│  │       │                                       │       │     │
│  │       │─────── SCK/SCLK (Serial Clock) ──────→│       │     │
│  │       │                                       │       │     │
│  │       │─────── SS/NSS/CS (Slave Select) ─────→│       │     │
│  └───────┘                                       └───────┘     │
│                                                                 │
│  Signal Description:                                            │
│  • MOSI : Data line from Master to Slave                       │
│  • MISO : Data line from Slave to Master                       │
│  • SCK  : Clock signal generated by Master                     │
│  • SS   : Slave Select (Active LOW) - selects the slave        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 How SPI Communication Works

```
Step-by-Step Communication:

1. Master pulls SS LOW to select slave
         SS: ‾‾‾‾\_____________/‾‾‾‾

2. Master generates clock signal
        SCK: ____/‾\_/‾\_/‾\_/‾\_____

3. Data shifts out on MOSI (Master → Slave)
       MOSI: ──<D7><D6><D5><D4>...

4. Data shifts in on MISO (Slave → Master)  
       MISO: ──<D7><D6><D5><D4>...

5. Master pulls SS HIGH to deselect slave
```

### 2.3 Data Transfer Mechanism

SPI uses **shift registers** for data transfer:

```
┌──────────────────────────────────────────────────────────────┐
│              SPI SHIFT REGISTER MECHANISM                    │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│     MASTER                              SLAVE                │
│  ┌─────────────────┐              ┌─────────────────┐       │
│  │ 8-bit Shift Reg │              │ 8-bit Shift Reg │       │
│  │ [7][6][5][4][3][2][1][0] │    │ [7][6][5][4][3][2][1][0] │
│  └────────┬────────────┬───┘     └───┬────────────┬────┘    │
│           │            │             │            │          │
│           │     MOSI   └─────────────┘            │          │
│           │            ←─────────────             │          │
│           │                   MISO                │          │
│           │                                       │          │
│           └───────────────────────────────────────┘          │
│                              SCK                             │
│                                                              │
│  With each clock pulse:                                      │
│  • MSB of Master shifts out through MOSI                    │
│  • MSB of Slave shifts out through MISO                     │
│  • After 8 clocks: Master and Slave have exchanged bytes    │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 2.4 Multiple Slave Configuration

```
┌──────────────────────────────────────────────────────────────┐
│              MULTIPLE SLAVE CONFIGURATION                    │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│                        MASTER                                │
│                       ┌──────┐                               │
│              MOSI ────│      │                               │
│              MISO ────│      │                               │
│              SCK  ────│      │                               │
│              SS1  ────│      │                               │
│              SS2  ────│      │                               │
│              SS3  ────│      │                               │
│                       └──────┘                               │
│                          │ │ │                               │
│           ┌──────────────┼─┼─┼──────────────┐               │
│           │              │ │ │              │               │
│           ▼              ▼ │ │              ▼               │
│       ┌───────┐      ┌───────┐          ┌───────┐          │
│       │SLAVE 1│      │SLAVE 2│          │SLAVE 3│          │
│       │SS=LOW │      │SS=HIGH│          │SS=HIGH│          │
│       │ACTIVE │      │INACTIVE│         │INACTIVE│         │
│       └───────┘      └───────┘          └───────┘          │
│                                                              │
│  Only ONE slave selected at a time (SS pulled LOW)          │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 3. SPI Communication Modes

### 3.1 Understanding CPOL and CPHA

SPI has **4 modes** determined by two parameters:
- **CPOL (Clock Polarity)**: Idle state of clock
- **CPHA (Clock Phase)**: When data is sampled

```
┌──────────────────────────────────────────────────────────────┐
│                    SPI MODES EXPLAINED                       │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  CPOL = 0: Clock idles LOW   ___/‾\_/‾\_/‾\___              │
│  CPOL = 1: Clock idles HIGH  ‾‾‾\_/‾\_/‾\_/‾‾‾              │
│                                                              │
│  CPHA = 0: Data sampled on FIRST edge (leading edge)        │
│  CPHA = 1: Data sampled on SECOND edge (trailing edge)      │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### 3.2 The Four SPI Modes

```
┌────────┬──────┬──────┬─────────────────────────────────────────┐
│  Mode  │ CPOL │ CPHA │ Description                             │
├────────┼──────┼──────┼─────────────────────────────────────────┤
│ Mode 0 │  0   │  0   │ Clock idle LOW, sample on rising edge  │
│ Mode 1 │  0   │  1   │ Clock idle LOW, sample on falling edge │
│ Mode 2 │  1   │  0   │ Clock idle HIGH, sample on falling edge│
│ Mode 3 │  1   │  1   │ Clock idle HIGH, sample on rising edge │
└────────┴──────┴──────┴─────────────────────────────────────────┘
```

### 3.3 Visual Representation of SPI Modes

```
MODE 0 (CPOL=0, CPHA=0) - Most Common
═══════════════════════════════════════
        ┌───┐   ┌───┐   ┌───┐   ┌───┐
SCK  ───┘   └───┘   └───┘   └───┘   └───
        ↑       ↑       ↑       ↑
     Sample  Sample  Sample  Sample
MOSI ─<D7>──<D6>──<D5>──<D4>──<D3>──...
       
MODE 1 (CPOL=0, CPHA=1)
═══════════════════════════════════════
        ┌───┐   ┌───┐   ┌───┐   ┌───┐
SCK  ───┘   └───┘   └───┘   └───┘   └───
            ↑       ↑       ↑       ↑
         Sample  Sample  Sample  Sample
MOSI ──<D7>──<D6>──<D5>──<D4>──<D3>─...

MODE 2 (CPOL=1, CPHA=0)
═══════════════════════════════════════
    ────┐   ┌───┐   ┌───┐   ┌───┐   ┌───
SCK     └───┘   └───┘   └───┘   └───┘
        ↑       ↑       ↑       ↑
     Sample  Sample  Sample  Sample

MODE 3 (CPOL=1, CPHA=1)
═══════════════════════════════════════
    ────┐   ┌───┐   ┌───┐   ┌───┐   ┌───
SCK     └───┘   └───┘   └───┘   └───┘
            ↑       ↑       ↑       ↑
         Sample  Sample  Sample  Sample
```

**Important**: Master and Slave MUST use the same mode!

### 3.4 Bus Configurations

```
┌──────────────────────────────────────────────────────────────┐
│                  SPI BUS CONFIGURATIONS                      │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  1. FULL DUPLEX (Default)                                   │
│     ─────────────────────                                   │
│     • Uses MOSI and MISO                                    │
│     • Simultaneous send and receive                         │
│     • Most common configuration                             │
│                                                              │
│     Master ──MOSI──→ Slave                                  │
│     Master ←──MISO── Slave                                  │
│                                                              │
│  2. HALF DUPLEX (Bidirectional)                             │
│     ───────────────────────────                             │
│     • Single data line (bidirectional)                      │
│     • Either send OR receive at a time                      │
│     • Saves one pin                                         │
│                                                              │
│     Master ←──DATA──→ Slave                                 │
│                                                              │
│  3. SIMPLEX (Transmit Only or Receive Only)                 │
│     ───────────────────────────────────────                 │
│     • One-way communication                                 │
│     • Example: Sending to LCD (transmit only)               │
│                                                              │
│     Master ──MOSI──→ Slave (Transmit Only)                  │
│     Master ←──MISO── Slave (Receive Only)                   │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## 4. Understanding SPI Registers

Before writing the driver, you must understand the SPI registers from the reference manual.

### 4.1 SPI Registers Overview (STM32F446)

| Register | Name | Purpose |
|----------|------|---------|
| SPI_CR1 | Control Register 1 | Main configuration (mode, speed, etc.) |
| SPI_CR2 | Control Register 2 | Interrupt and DMA control |
| SPI_SR | Status Register | Flags (TXE, RXNE, BSY, etc.) |
| SPI_DR | Data Register | Send/receive data |
| SPI_CRCPR | CRC Polynomial | CRC calculation |
| SPI_RXCRCR | RX CRC | Received CRC value |
| SPI_TXCRCR | TX CRC | Transmitted CRC value |
| SPI_I2SCFGR | I2S Config | I2S mode configuration |
| SPI_I2SPR | I2S Prescaler | I2S clock prescaler |

### 4.2 SPI_CR1 Register (Control Register 1)

This is the most important register for basic SPI configuration.

```
┌──────────────────────────────────────────────────────────────────┐
│                    SPI_CR1 REGISTER (0x00)                       │
├──────────────────────────────────────────────────────────────────┤
│ Bit  │ Name     │ Description                                   │
├──────┼──────────┼───────────────────────────────────────────────┤
│  15  │ BIDIMODE │ Bidirectional mode: 0=2-line, 1=1-line        │
│  14  │ BIDIOE   │ Output enable in bidirectional mode           │
│  13  │ CRCEN    │ CRC calculation enable                        │
│  12  │ CRCNEXT  │ CRC transfer next                             │
│  11  │ DFF      │ Data frame format: 0=8-bit, 1=16-bit          │
│  10  │ RXONLY   │ Receive only mode                             │
│   9  │ SSM      │ Software slave management: 0=HW, 1=SW         │
│   8  │ SSI      │ Internal slave select (when SSM=1)            │
│   7  │ LSBFIRST │ Frame format: 0=MSB first, 1=LSB first        │
│   6  │ SPE      │ SPI Enable: 0=Disabled, 1=Enabled             │
│ 5:3  │ BR[2:0]  │ Baud rate control (clock divider)             │
│   2  │ MSTR     │ Master selection: 0=Slave, 1=Master           │
│   1  │ CPOL     │ Clock polarity: 0=Low idle, 1=High idle       │
│   0  │ CPHA     │ Clock phase: 0=1st edge, 1=2nd edge           │
└──────┴──────────┴───────────────────────────────────────────────┘

BR[2:0] - Baud Rate Settings:
┌───────┬────────────────┐
│ Value │ Clock Divider  │
├───────┼────────────────┤
│  000  │ fPCLK / 2      │
│  001  │ fPCLK / 4      │
│  010  │ fPCLK / 8      │
│  011  │ fPCLK / 16     │
│  100  │ fPCLK / 32     │
│  101  │ fPCLK / 64     │
│  110  │ fPCLK / 128    │
│  111  │ fPCLK / 256    │
└───────┴────────────────┘
```

### 4.3 SPI_CR2 Register (Control Register 2)

```
┌──────────────────────────────────────────────────────────────────┐
│                    SPI_CR2 REGISTER (0x04)                       │
├──────────────────────────────────────────────────────────────────┤
│ Bit  │ Name     │ Description                                   │
├──────┼──────────┼───────────────────────────────────────────────┤
│   7  │ TXEIE    │ TX buffer empty interrupt enable              │
│   6  │ RXNEIE   │ RX buffer not empty interrupt enable          │
│   5  │ ERRIE    │ Error interrupt enable                        │
│   4  │ FRF      │ Frame format (Motorola/TI mode)               │
│   2  │ SSOE     │ SS output enable (Master mode)                │
│   1  │ TXDMAEN  │ TX DMA enable                                 │
│   0  │ RXDMAEN  │ RX DMA enable                                 │
└──────┴──────────┴───────────────────────────────────────────────┘
```

### 4.4 SPI_SR Register (Status Register)

```
┌──────────────────────────────────────────────────────────────────┐
│                    SPI_SR REGISTER (0x08)                        │
├──────────────────────────────────────────────────────────────────┤
│ Bit  │ Name     │ Description                                   │
├──────┼──────────┼───────────────────────────────────────────────┤
│   8  │ FRE      │ Frame format error (TI mode)                  │
│   7  │ BSY      │ Busy flag: 1=SPI busy                         │
│   6  │ OVR      │ Overrun flag                                  │
│   5  │ MODF     │ Mode fault                                    │
│   4  │ CRCERR   │ CRC error flag                                │
│   3  │ UDR      │ Underrun flag (slave mode)                    │
│   2  │ CHSIDE   │ Channel side (I2S mode)                       │
│   1  │ TXE      │ TX buffer empty: 1=Empty, ready to send       │
│   0  │ RXNE     │ RX buffer not empty: 1=Data received          │
└──────┴──────────┴───────────────────────────────────────────────┘

IMPORTANT FLAGS FOR DRIVER:
• TXE (Bit 1):  Check before writing to DR (must be 1)
• RXNE (Bit 0): Check before reading from DR (must be 1)
• BSY (Bit 7):  Check before disabling SPI (must be 0)
• OVR (Bit 6):  Overrun error - data lost
```

### 4.5 SPI_DR Register (Data Register)

```
┌──────────────────────────────────────────────────────────────────┐
│                    SPI_DR REGISTER (0x0C)                        │
├──────────────────────────────────────────────────────────────────┤
│                                                                  │
│  • 16-bit register for data transmission and reception          │
│  • Writing to DR loads data into TX buffer                      │
│  • Reading from DR reads data from RX buffer                    │
│                                                                  │
│  For 8-bit mode:  Only lower 8 bits used                        │
│  For 16-bit mode: All 16 bits used                              │
│                                                                  │
│  USAGE:                                                          │
│  ──────                                                          │
│  To SEND:    SPIx->DR = data;     // Write to DR                │
│  To RECEIVE: data = SPIx->DR;     // Read from DR               │
│                                                                  │
│  NOTE: In full-duplex mode, writing to DR triggers clock        │
│        and simultaneously sends and receives data               │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

---

## 5. Driver Architecture

### 5.1 Files Required

```
┌─────────────────────────────────────────────────────────────────┐
│                    SPI DRIVER ARCHITECTURE                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. MCU Header File (stm32f446xx.h)                            │
│     ───────────────────────────────                            │
│     • SPI register definition structure                         │
│     • SPI peripheral base addresses                             │
│     • SPI peripheral pointers                                   │
│     • Clock enable/disable macros                               │
│     • Bit position definitions                                  │
│                                                                 │
│  2. SPI Driver Header (stm32f446xx_spi_driver.h)               │
│     ─────────────────────────────────────────                  │
│     • SPI configuration structure                               │
│     • SPI handle structure                                      │
│     • Configuration macros                                      │
│     • API function prototypes                                   │
│                                                                 │
│  3. SPI Driver Source (stm32f446xx_spi_driver.c)               │
│     ─────────────────────────────────────────                  │
│     • Clock control function                                    │
│     • Initialization function                                   │
│     • Data send/receive functions                               │
│     • Interrupt handling functions                              │
│     • Helper functions                                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 Development Workflow

```
┌─────────────────────────────────────────────────────────────────┐
│                STEP-BY-STEP DEVELOPMENT FLOW                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  STEP 1: Study Reference Manual                                │
│  ──────────────────────────────                                │
│  • Find SPI chapter                                            │
│  • Document all registers and their offsets                    │
│  • Understand each bit field                                   │
│                                                                 │
│              ↓                                                  │
│                                                                 │
│  STEP 2: Update MCU Header File                                │
│  ──────────────────────────────                                │
│  • Add SPI register structure                                  │
│  • Add base addresses                                          │
│  • Add clock macros                                            │
│  • Add bit position macros                                     │
│                                                                 │
│              ↓                                                  │
│                                                                 │
│  STEP 3: Create Driver Header File                             │
│  ─────────────────────────────────                             │
│  • Define configuration structure                              │
│  • Define handle structure                                     │
│  • Create configuration macros                                 │
│  • Declare API prototypes                                      │
│                                                                 │
│              ↓                                                  │
│                                                                 │
│  STEP 4: Implement Driver Functions                            │
│  ──────────────────────────────────                            │
│  • Clock control                                               │
│  • Initialization                                              │
│  • Send data (blocking)                                        │
│  • Receive data (blocking)                                     │
│  • Interrupt handling                                          │
│                                                                 │
│              ↓                                                  │
│                                                                 │
│  STEP 5: Test the Driver                                       │
│  ────────────────────────                                      │
│  • Loopback test                                               │
│  • Communication with slave device                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. Step 1: MCU Header File Setup

### 6.1 Add SPI Register Definition Structure

Add this to your `stm32f446xx.h` file:

```c
/*
 * Peripheral register definition structure for SPI
 * Each member represents a 32-bit register
 */
typedef struct
{
    __vo uint32_t CR1;        /*!< SPI control register 1,        Address offset: 0x00 */
    __vo uint32_t CR2;        /*!< SPI control register 2,        Address offset: 0x04 */
    __vo uint32_t SR;         /*!< SPI status register,           Address offset: 0x08 */
    __vo uint32_t DR;         /*!< SPI data register,             Address offset: 0x0C */
    __vo uint32_t CRCPR;      /*!< SPI CRC polynomial register,   Address offset: 0x10 */
    __vo uint32_t RXCRCR;     /*!< SPI RX CRC register,           Address offset: 0x14 */
    __vo uint32_t TXCRCR;     /*!< SPI TX CRC register,           Address offset: 0x18 */
    __vo uint32_t I2SCFGR;    /*!< SPI_I2S configuration register,Address offset: 0x1C */
    __vo uint32_t I2SPR;      /*!< SPI_I2S prescaler register,    Address offset: 0x20 */
} SPI_RegDef_t;
```

### 6.2 Add SPI Base Addresses

```c
/*
 * Base addresses of SPI peripherals
 * SPI1 is on APB2 bus
 * SPI2, SPI3, SPI4 are on APB1 bus
 */
#define SPI1_BASEADDR       (APB2PERIPH_BASEADDR + 0x3000)
#define SPI2_BASEADDR       (APB1PERIPH_BASEADDR + 0x3800)
#define SPI3_BASEADDR       (APB1PERIPH_BASEADDR + 0x3C00)
#define SPI4_BASEADDR       (APB2PERIPH_BASEADDR + 0x3400)
```

### 6.3 Add SPI Peripheral Pointers

```c
/*
 * SPI peripheral definitions (base addresses typecasted to SPI_RegDef_t*)
 */
#define SPI1    ((SPI_RegDef_t*)SPI1_BASEADDR)
#define SPI2    ((SPI_RegDef_t*)SPI2_BASEADDR)
#define SPI3    ((SPI_RegDef_t*)SPI3_BASEADDR)
#define SPI4    ((SPI_RegDef_t*)SPI4_BASEADDR)
```

### 6.4 Add Clock Enable/Disable Macros

```c
/*
 * Clock Enable Macros for SPIx peripherals
 */
#define SPI1_PCLK_EN()      (RCC->APB2ENR |= (1 << 12))
#define SPI2_PCLK_EN()      (RCC->APB1ENR |= (1 << 14))
#define SPI3_PCLK_EN()      (RCC->APB1ENR |= (1 << 15))
#define SPI4_PCLK_EN()      (RCC->APB2ENR |= (1 << 13))

/*
 * Clock Disable Macros for SPIx peripherals
 */
#define SPI1_PCLK_DI()      (RCC->APB2ENR &= ~(1 << 12))
#define SPI2_PCLK_DI()      (RCC->APB1ENR &= ~(1 << 14))
#define SPI3_PCLK_DI()      (RCC->APB1ENR &= ~(1 << 15))
#define SPI4_PCLK_DI()      (RCC->APB2ENR &= ~(1 << 13))
```

### 6.5 Add Bit Position Definitions

```c
/*
 * Bit position definitions for SPI_CR1 register
 */
#define SPI_CR1_CPHA        0
#define SPI_CR1_CPOL        1
#define SPI_CR1_MSTR        2
#define SPI_CR1_BR          3
#define SPI_CR1_SPE         6
#define SPI_CR1_LSBFIRST    7
#define SPI_CR1_SSI         8
#define SPI_CR1_SSM         9
#define SPI_CR1_RXONLY      10
#define SPI_CR1_DFF         11
#define SPI_CR1_CRCNEXT     12
#define SPI_CR1_CRCEN       13
#define SPI_CR1_BIDIOE      14
#define SPI_CR1_BIDIMODE    15

/*
 * Bit position definitions for SPI_CR2 register
 */
#define SPI_CR2_RXDMAEN     0
#define SPI_CR2_TXDMAEN     1
#define SPI_CR2_SSOE        2
#define SPI_CR2_FRF         4
#define SPI_CR2_ERRIE       5
#define SPI_CR2_RXNEIE      6
#define SPI_CR2_TXEIE       7

/*
 * Bit position definitions for SPI_SR register
 */
#define SPI_SR_RXNE         0
#define SPI_SR_TXE          1
#define SPI_SR_CHSIDE       2
#define SPI_SR_UDR          3
#define SPI_SR_CRCERR       4
#define SPI_SR_MODF         5
#define SPI_SR_OVR          6
#define SPI_SR_BSY          7
#define SPI_SR_FRE          8
```

---

## 7. Step 2: SPI Driver Header File

### 7.1 File Structure and Includes

```c
/*
 * stm32f446xx_spi_driver.h
 * SPI Driver Header File for STM32F446xx
 */

#ifndef STM32F446XX_SPI_DRIVER_H_
#define STM32F446XX_SPI_DRIVER_H_

#include "stm32f446xx.h"
```

### 7.2 Configuration Structure

This structure holds all user-configurable parameters:

```c
/*
 * SPI Configuration Structure
 * 
 * User fills this structure to configure SPI peripheral
 */
typedef struct
{
    uint8_t SPI_DeviceMode;     /*!< Master or Slave mode - @SPI_DeviceMode */
    uint8_t SPI_BusConfig;      /*!< Full-duplex, Half-duplex, Simplex - @SPI_BusConfig */
    uint8_t SPI_SclkSpeed;      /*!< Serial clock speed - @SPI_SclkSpeed */
    uint8_t SPI_DFF;            /*!< Data frame format (8/16 bit) - @SPI_DFF */
    uint8_t SPI_CPOL;           /*!< Clock polarity - @SPI_CPOL */
    uint8_t SPI_CPHA;           /*!< Clock phase - @SPI_CPHA */
    uint8_t SPI_SSM;            /*!< Slave select management (SW/HW) - @SPI_SSM */
} SPI_Config_t;
```

### 7.3 Handle Structure

```c
/*
 * SPI Handle Structure
 * 
 * Contains peripheral pointer + configuration + state information
 */
typedef struct
{
    SPI_RegDef_t    *pSPIx;         /*!< Base address of SPIx peripheral */
    SPI_Config_t    SPIConfig;      /*!< SPI configuration settings */
    uint8_t         *pTxBuffer;     /*!< Pointer to TX buffer (for interrupt mode) */
    uint8_t         *pRxBuffer;     /*!< Pointer to RX buffer (for interrupt mode) */
    uint32_t        TxLen;          /*!< TX length */
    uint32_t        RxLen;          /*!< RX length */
    uint8_t         TxState;        /*!< TX state */
    uint8_t         RxState;        /*!< RX state */
} SPI_Handle_t;
```

### 7.3.1 Why Do We Need the Handle Structure?

Think of the **Handle Structure** as a **"control panel"** for managing an SPI peripheral. Without it, you would need to pass many individual parameters to every function, which would be messy and error-prone.

```
WITHOUT HANDLE STRUCTURE (Bad Approach):
════════════════════════════════════════

void SPI_Init(SPI_RegDef_t *pSPIx, 
              uint8_t deviceMode, 
              uint8_t busConfig,
              uint8_t speed,
              uint8_t dff,
              uint8_t cpol,
              uint8_t cpha,
              uint8_t ssm);

void SPI_SendData(SPI_RegDef_t *pSPIx,
                  uint8_t *buffer,
                  uint32_t len,
                  uint8_t *txBuffer,    // For interrupt mode
                  uint32_t *txLen,      // For interrupt mode
                  uint8_t *state);      // For interrupt mode

// Too many parameters! Hard to manage!


WITH HANDLE STRUCTURE (Good Approach):
═══════════════════════════════════════

void SPI_Init(SPI_Handle_t *pSPIHandle);
void SPI_SendData(SPI_Handle_t *pSPIHandle, uint8_t *buffer, uint32_t len);

// Clean and simple! All information packaged in one structure.
```

### 7.3.2 The Two Structures Relationship

We have **TWO** structures that work together:

```
┌─────────────────────────────────────────────────────────────────┐
│                    STRUCTURE RELATIONSHIP                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │              SPI_Config_t (Configuration)                │  │
│   │  ─────────────────────────────────────────────────────  │  │
│   │  Contains: User settings (mode, speed, CPOL, etc.)      │  │
│   │  Purpose:  WHAT the user wants to configure             │  │
│   └─────────────────────────────────────────────────────────┘  │
│                              │                                  │
│                              │ (is part of)                     │
│                              ▼                                  │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │              SPI_Handle_t (Handle)                       │  │
│   │  ─────────────────────────────────────────────────────  │  │
│   │  Contains: Peripheral pointer + Config + Runtime state  │  │
│   │  Purpose:  Complete control of an SPI instance          │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 7.3.3 Configuration Structure Members Explained

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_DeviceMode                                         │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: Is this STM32 the MASTER or SLAVE?                            │
│                                                                           │
│  Values:                                                                  │
│  • SPI_DEVICE_MODE_MASTER (1) - STM32 generates clock, controls transfer │
│  • SPI_DEVICE_MODE_SLAVE  (0) - STM32 responds to external master        │
│                                                                           │
│  MASTER:                          SLAVE:                                  │
│  ┌─────────┐    SCK    ┌───────┐  ┌─────────┐    SCK    ┌───────┐       │
│  │  STM32  │──────────→│ Slave │  │ Master  │──────────→│ STM32 │       │
│  │ (Master)│           │Device │  │ Device  │           │(Slave)│       │
│  └─────────┘           └───────┘  └─────────┘           └───────┘       │
│                                                                           │
│  Register: CR1, Bit 2 (MSTR)                                             │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_BusConfig                                          │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: How many data lines and in which direction?                   │
│                                                                           │
│  Values:                                                                  │
│  • SPI_BUS_CONFIG_FD (1)           - Full Duplex (2 lines: MOSI + MISO) │
│  • SPI_BUS_CONFIG_HD (2)           - Half Duplex (1 line: bidirectional)│
│  • SPI_BUS_CONFIG_SIMPLEX_RXONLY (3) - Receive Only                      │
│                                                                           │
│  FULL DUPLEX (Most Common):                                              │
│  ┌───────┐    MOSI    ┌───────┐                                          │
│  │Master │───────────→│ Slave │   Both directions simultaneously         │
│  │       │←───────────│       │                                          │
│  └───────┘    MISO    └───────┘                                          │
│                                                                           │
│  HALF DUPLEX:                                                            │
│  ┌───────┐   DATA     ┌───────┐                                          │
│  │Master │←──────────→│ Slave │   One direction at a time                │
│  └───────┘  (1 line)  └───────┘                                          │
│                                                                           │
│  Register: CR1, Bits 15 (BIDIMODE) and 10 (RXONLY)                       │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_SclkSpeed                                          │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: How fast should the SPI clock be?                             │
│                                                                           │
│  The clock is derived from APB bus clock (PCLK) divided by a prescaler.  │
│                                                                           │
│  Values and resulting clock (assuming PCLK = 16MHz):                     │
│  ┌────────────────────────┬──────────────┬───────────────┐               │
│  │ Macro                  │ Divider      │ Clock Speed   │               │
│  ├────────────────────────┼──────────────┼───────────────┤               │
│  │ SPI_SCLK_SPEED_DIV2   │ PCLK / 2     │ 8 MHz         │               │
│  │ SPI_SCLK_SPEED_DIV4   │ PCLK / 4     │ 4 MHz         │               │
│  │ SPI_SCLK_SPEED_DIV8   │ PCLK / 8     │ 2 MHz         │               │
│  │ SPI_SCLK_SPEED_DIV16  │ PCLK / 16    │ 1 MHz         │               │
│  │ SPI_SCLK_SPEED_DIV32  │ PCLK / 32    │ 500 KHz       │               │
│  │ SPI_SCLK_SPEED_DIV64  │ PCLK / 64    │ 250 KHz       │               │
│  │ SPI_SCLK_SPEED_DIV128 │ PCLK / 128   │ 125 KHz       │               │
│  │ SPI_SCLK_SPEED_DIV256 │ PCLK / 256   │ 62.5 KHz      │               │
│  └────────────────────────┴──────────────┴───────────────┘               │
│                                                                           │
│  TIP: Start with slower speed (DIV256) for testing, increase later       │
│                                                                           │
│  Register: CR1, Bits 5:3 (BR[2:0])                                       │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_DFF (Data Frame Format)                            │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: How many bits per data frame - 8 or 16?                       │
│                                                                           │
│  Values:                                                                  │
│  • SPI_DFF_8BITS  (0) - Send/receive 1 byte at a time                   │
│  • SPI_DFF_16BITS (1) - Send/receive 2 bytes at a time                  │
│                                                                           │
│  8-BIT MODE:                        16-BIT MODE:                         │
│  ┌─┬─┬─┬─┬─┬─┬─┬─┐                 ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐    │
│  │7│6│5│4│3│2│1│0│                 │F│E│D│C│B│A│9│8│7│6│5│4│3│2│1│0│    │
│  └─┴─┴─┴─┴─┴─┴─┴─┘                 └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘    │
│      8 bits                              16 bits                         │
│                                                                           │
│  IMPORTANT: This affects how you write to/read from DR register!         │
│                                                                           │
│  Register: CR1, Bit 11 (DFF)                                             │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_CPOL (Clock Polarity)                              │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: What is the clock level when SPI is idle (not transferring)?  │
│                                                                           │
│  Values:                                                                  │
│  • SPI_CPOL_LOW  (0) - Clock is LOW when idle                           │
│  • SPI_CPOL_HIGH (1) - Clock is HIGH when idle                          │
│                                                                           │
│  CPOL = 0 (Low idle):               CPOL = 1 (High idle):                │
│       ┌─┐ ┌─┐ ┌─┐ ┌─┐                  ─┐ ┌─┐ ┌─┐ ┌─┐ ┌─                 │
│  ─────┘ └─┘ └─┘ └─┘ └─────            └─┘ └─┘ └─┘ └─┘                    │
│  idle ↑              ↑ idle      idle ↑              ↑ idle              │
│       transfer                        transfer                           │
│                                                                           │
│  MUST MATCH YOUR SLAVE DEVICE'S SETTING!                                 │
│                                                                           │
│  Register: CR1, Bit 1 (CPOL)                                             │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_CPHA (Clock Phase)                                 │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: On which clock edge should data be sampled (read)?            │
│                                                                           │
│  Values:                                                                  │
│  • SPI_CPHA_LOW  (0) - Sample on FIRST edge (leading edge)              │
│  • SPI_CPHA_HIGH (1) - Sample on SECOND edge (trailing edge)            │
│                                                                           │
│  CPHA = 0 (First edge):                                                  │
│        ┌───┐   ┌───┐                                                     │
│  CLK ──┘   └───┘   └──                                                   │
│        ↑       ↑                                                         │
│     SAMPLE  SAMPLE                                                       │
│                                                                           │
│  CPHA = 1 (Second edge):                                                 │
│        ┌───┐   ┌───┐                                                     │
│  CLK ──┘   └───┘   └──                                                   │
│            ↑       ↑                                                     │
│         SAMPLE  SAMPLE                                                   │
│                                                                           │
│  MUST MATCH YOUR SLAVE DEVICE'S SETTING!                                 │
│                                                                           │
│  Register: CR1, Bit 0 (CPHA)                                             │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPI_SSM (Software Slave Management)                    │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  QUESTION: How is the NSS (slave select) pin controlled?                 │
│                                                                           │
│  Values:                                                                  │
│  • SPI_SSM_DI (0) - Hardware management (NSS pin used)                  │
│  • SPI_SSM_EN (1) - Software management (NSS pin not used, use GPIO)    │
│                                                                           │
│  HARDWARE MANAGEMENT (SSM=0):                                            │
│  ┌───────────┐                                                           │
│  │   STM32   │                                                           │
│  │   ┌───┐   │    NSS                                                    │
│  │   │SPI├───┼──────────→ Slave (controlled by SPI hardware)            │
│  │   └───┘   │                                                           │
│  └───────────┘                                                           │
│                                                                           │
│  SOFTWARE MANAGEMENT (SSM=1):                                            │
│  ┌───────────┐                                                           │
│  │   STM32   │                                                           │
│  │   ┌───┐   │    (NSS pin not connected)                               │
│  │   │SPI│   │                                                           │
│  │   └───┘   │    GPIO                                                   │
│  │   ┌───┐   │                                                           │
│  │   │PA4├───┼──────────→ Slave (controlled by your code)               │
│  │   └───┘   │                                                           │
│  └───────────┘                                                           │
│                                                                           │
│  FOR BEGINNERS: Use SSM=1 (software) - more control and flexibility     │
│                                                                           │
│  Register: CR1, Bit 9 (SSM)                                              │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘
```

### 7.3.4 Handle Structure Members Explained

```
┌───────────────────────────────────────────────────────────────────────────┐
│                    pSPIx (Peripheral Pointer)                             │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  PURPOSE: Points to the base address of the SPI peripheral               │
│                                                                           │
│  Type: SPI_RegDef_t* (pointer to SPI register structure)                 │
│                                                                           │
│  Values: SPI1, SPI2, SPI3, or SPI4                                       │
│                                                                           │
│  WHY NEEDED:                                                             │
│  • STM32F446 has 4 SPI peripherals                                       │
│  • This tells the driver WHICH SPI to use                                │
│  • Driver uses this to access the correct registers                      │
│                                                                           │
│  EXAMPLE:                                                                 │
│  SPI_Handle_t spiHandle;                                                 │
│  spiHandle.pSPIx = SPI2;  // Use SPI2 peripheral                        │
│                                                                           │
│  MEMORY MAP:                                                             │
│  SPI1 → 0x40013000 (APB2)                                                │
│  SPI2 → 0x40003800 (APB1)  ← spiHandle.pSPIx points here                │
│  SPI3 → 0x40003C00 (APB1)                                                │
│  SPI4 → 0x40013400 (APB2)                                                │
│                                                                           │
│  This pointer allows:                                                    │
│  spiHandle.pSPIx->CR1 = ...   // Access CR1 register                    │
│  spiHandle.pSPIx->DR = ...    // Access DR register                     │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    SPIConfig (Configuration Settings)                     │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  PURPOSE: Stores all user configuration for this SPI instance            │
│                                                                           │
│  Type: SPI_Config_t (nested structure - explained above)                 │
│                                                                           │
│  WHY NEEDED:                                                             │
│  • Groups all configuration in one place                                 │
│  • Used by SPI_Init() to configure the peripheral                        │
│  • Can be referenced later if needed                                     │
│                                                                           │
│  EXAMPLE:                                                                 │
│  SPI_Handle_t spiHandle;                                                 │
│  spiHandle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;           │
│  spiHandle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;                  │
│  spiHandle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV8;               │
│  spiHandle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;                           │
│  spiHandle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;                           │
│  spiHandle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;                           │
│  spiHandle.SPIConfig.SPI_SSM = SPI_SSM_EN;                              │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│              pTxBuffer & pRxBuffer (Buffer Pointers)                      │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  PURPOSE: Store pointers to user's data buffers (for INTERRUPT mode)     │
│                                                                           │
│  Type: uint8_t* (pointer to byte array)                                  │
│                                                                           │
│  WHY NEEDED (ONLY for interrupt-based communication):                    │
│                                                                           │
│  In BLOCKING mode:                                                       │
│  ─────────────────                                                       │
│  • User passes buffer directly to function                               │
│  • Function waits until all data is sent/received                        │
│  • Buffer pointers in handle NOT used                                    │
│                                                                           │
│  In INTERRUPT mode:                                                      │
│  ──────────────────                                                      │
│  • User calls function, which returns IMMEDIATELY                        │
│  • Data transfer happens in background via interrupts                    │
│  • ISR needs to know WHERE the data is → saved in handle                │
│                                                                           │
│  FLOW:                                                                   │
│  1. User calls SPI_SendDataIT(&handle, myData, 10)                      │
│  2. Function saves: handle.pTxBuffer = myData                           │
│  3. Function enables TXE interrupt and returns                          │
│  4. When TXE interrupt fires:                                            │
│     - ISR reads next byte from handle.pTxBuffer                         │
│     - ISR increments handle.pTxBuffer                                   │
│     - ISR decrements handle.TxLen                                       │
│  5. Repeat until TxLen = 0                                              │
│                                                                           │
│  VISUAL:                                                                 │
│  User's buffer:     [A][B][C][D][E][F][G][H][I][J]                       │
│                      ↑                                                   │
│                      pTxBuffer (points here initially)                   │
│                                                                           │
│  After 3 bytes:     [A][B][C][D][E][F][G][H][I][J]                       │
│                               ↑                                          │
│                               pTxBuffer (moved forward)                  │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    TxLen & RxLen (Length Counters)                        │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  PURPOSE: Track how many bytes are left to send/receive                  │
│                                                                           │
│  Type: uint32_t (unsigned 32-bit integer)                                │
│                                                                           │
│  WHY NEEDED (for interrupt mode):                                        │
│  • ISR needs to know when transfer is complete                           │
│  • Decremented after each byte sent/received                             │
│  • When reaches 0, transfer is done                                      │
│                                                                           │
│  EXAMPLE FLOW (Sending 5 bytes):                                         │
│                                                                           │
│  Initial:     TxLen = 5                                                  │
│  After ISR 1: TxLen = 4   (1 byte sent)                                 │
│  After ISR 2: TxLen = 3   (2 bytes sent)                                │
│  After ISR 3: TxLen = 2   (3 bytes sent)                                │
│  After ISR 4: TxLen = 1   (4 bytes sent)                                │
│  After ISR 5: TxLen = 0   (5 bytes sent) → DONE! Disable interrupt      │
│                                                                           │
│  CODE IN ISR:                                                            │
│  if (handle->TxLen > 0)                                                  │
│  {                                                                       │
│      pSPIx->DR = *(handle->pTxBuffer);  // Send byte                    │
│      handle->pTxBuffer++;                // Move to next byte           │
│      handle->TxLen--;                    // Decrement counter           │
│  }                                                                       │
│  if (handle->TxLen == 0)                                                 │
│  {                                                                       │
│      // Transfer complete! Disable interrupt                            │
│  }                                                                       │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘

┌───────────────────────────────────────────────────────────────────────────┐
│                    TxState & RxState (State Variables)                    │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  PURPOSE: Track the current state of TX and RX operations                │
│                                                                           │
│  Type: uint8_t                                                           │
│                                                                           │
│  Possible Values:                                                        │
│  • SPI_READY (0)       - SPI is idle, ready for new operation           │
│  • SPI_BUSY_IN_TX (2)  - SPI is currently transmitting                  │
│  • SPI_BUSY_IN_RX (1)  - SPI is currently receiving                     │
│                                                                           │
│  WHY NEEDED:                                                             │
│  1. PREVENT CONFLICTS: Don't start new transfer while one is ongoing    │
│  2. APPLICATION AWARENESS: Know when transfer is complete               │
│  3. DEBUGGING: Know what SPI is doing                                   │
│                                                                           │
│  STATE MACHINE:                                                          │
│                                                                           │
│      ┌─────────────┐                                                     │
│      │  SPI_READY  │◄────────────────────────────────┐                  │
│      └──────┬──────┘                                 │                  │
│             │                                        │                  │
│    User calls              Transfer                  │                  │
│    SendDataIT()            complete                  │                  │
│             │                                        │                  │
│             ▼                                        │                  │
│      ┌─────────────────┐                            │                  │
│      │ SPI_BUSY_IN_TX  │────────────────────────────┘                  │
│      └─────────────────┘                                                │
│                                                                           │
│  CODE EXAMPLE:                                                           │
│                                                                           │
│  uint8_t SPI_SendDataIT(SPI_Handle_t *handle, uint8_t *data, uint32_t len)│
│  {                                                                       │
│      if (handle->TxState != SPI_BUSY_IN_TX)  // Check if free           │
│      {                                                                   │
│          handle->TxState = SPI_BUSY_IN_TX;   // Mark as busy            │
│          handle->pTxBuffer = data;                                      │
│          handle->TxLen = len;                                           │
│          // Enable interrupt...                                         │
│      }                                                                   │
│      return handle->TxState;                                            │
│  }                                                                       │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘
```

### 7.3.5 Complete Handle Structure Usage Example

Here's how all the pieces come together:

```c
#include "stm32f446xx_spi_driver.h"

int main(void)
{
    /*
     * STEP 1: Create and initialize the Handle Structure
     */
    SPI_Handle_t SPI2Handle;
    
    // Set which SPI peripheral to use
    SPI2Handle.pSPIx = SPI2;
    
    // Fill in the configuration
    SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
    SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
    SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV8;
    SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
    SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
    SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
    SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_EN;
    
    // Initialize state variables (for interrupt mode)
    SPI2Handle.TxState = SPI_READY;
    SPI2Handle.RxState = SPI_READY;
    SPI2Handle.pTxBuffer = NULL;
    SPI2Handle.pRxBuffer = NULL;
    SPI2Handle.TxLen = 0;
    SPI2Handle.RxLen = 0;
    
    /*
     * STEP 2: Pass the handle to init function
     * The function reads ALL configuration from the handle
     */
    SPI_Init(&SPI2Handle);
    
    /*
     * STEP 3: Use the handle for operations
     */
    uint8_t data[] = "Hello";
    
    SPI_SSIConfig(SPI2Handle.pSPIx, ENABLE);
    SPI_PeripheralControl(SPI2Handle.pSPIx, ENABLE);
    
    // For blocking mode - just pass peripheral pointer and data
    SPI_SendData(SPI2Handle.pSPIx, data, 5);
    
    // For interrupt mode - pass the entire handle
    // SPI_SendDataIT(&SPI2Handle, data, 5);
    
    while(1);
}
```

### 7.3.6 Handle Structure Summary

```
┌───────────────────────────────────────────────────────────────────────────┐
│                           SUMMARY                                         │
├───────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  The HANDLE STRUCTURE serves THREE main purposes:                        │
│                                                                           │
│  1. IDENTIFY THE PERIPHERAL                                              │
│     └─→ pSPIx tells driver which SPI (SPI1, SPI2, etc.)                 │
│                                                                           │
│  2. STORE CONFIGURATION                                                  │
│     └─→ SPIConfig holds all user settings in one place                  │
│                                                                           │
│  3. MANAGE RUNTIME STATE (for interrupt mode)                            │
│     ├─→ pTxBuffer, pRxBuffer: Where is the data?                        │
│     ├─→ TxLen, RxLen: How much data left?                               │
│     └─→ TxState, RxState: What is SPI doing now?                        │
│                                                                           │
│  BLOCKING MODE: Uses pSPIx and SPIConfig only                           │
│  INTERRUPT MODE: Uses ALL members                                        │
│                                                                           │
└───────────────────────────────────────────────────────────────────────────┘
```

### 7.4 Configuration Macros

```c
/*
 * @SPI_DeviceMode - Master or Slave
 */
#define SPI_DEVICE_MODE_SLAVE       0
#define SPI_DEVICE_MODE_MASTER      1

/*
 * @SPI_BusConfig - Bus configuration options
 */
#define SPI_BUS_CONFIG_FD               1   // Full Duplex
#define SPI_BUS_CONFIG_HD               2   // Half Duplex
#define SPI_BUS_CONFIG_SIMPLEX_RXONLY   3   // Simplex RX Only

/*
 * @SPI_SclkSpeed - Clock speed (prescaler values)
 */
#define SPI_SCLK_SPEED_DIV2         0   // fPCLK / 2
#define SPI_SCLK_SPEED_DIV4         1   // fPCLK / 4
#define SPI_SCLK_SPEED_DIV8         2   // fPCLK / 8
#define SPI_SCLK_SPEED_DIV16        3   // fPCLK / 16
#define SPI_SCLK_SPEED_DIV32        4   // fPCLK / 32
#define SPI_SCLK_SPEED_DIV64        5   // fPCLK / 64
#define SPI_SCLK_SPEED_DIV128       6   // fPCLK / 128
#define SPI_SCLK_SPEED_DIV256       7   // fPCLK / 256

/*
 * @SPI_DFF - Data frame format
 */
#define SPI_DFF_8BITS       0
#define SPI_DFF_16BITS      1

/*
 * @SPI_CPOL - Clock polarity
 */
#define SPI_CPOL_LOW        0   // Clock idles LOW
#define SPI_CPOL_HIGH       1   // Clock idles HIGH

/*
 * @SPI_CPHA - Clock phase
 */
#define SPI_CPHA_LOW        0   // Sample on first edge
#define SPI_CPHA_HIGH       1   // Sample on second edge

/*
 * @SPI_SSM - Software slave management
 */
#define SPI_SSM_DI          0   // Hardware slave management
#define SPI_SSM_EN          1   // Software slave management

/*
 * SPI application states (for interrupt mode)
 */
#define SPI_READY           0
#define SPI_BUSY_IN_RX      1
#define SPI_BUSY_IN_TX      2

/*
 * SPI Status flags
 */
#define SPI_TXE_FLAG        (1 << SPI_SR_TXE)
#define SPI_RXNE_FLAG       (1 << SPI_SR_RXNE)
#define SPI_BUSY_FLAG       (1 << SPI_SR_BSY)
```

### 7.5 API Function Prototypes

```c
/*******************************************************************************
 *                         APIs Supported by this Driver
 ******************************************************************************/

/*
 * Peripheral Clock Setup
 */
void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi);

/*
 * Init and De-Init
 */
void SPI_Init(SPI_Handle_t *pSPIHandle);
void SPI_DeInit(SPI_RegDef_t *pSPIx);

/*
 * Data Send and Receive (Blocking/Polling)
 */
void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len);
void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len);

/*
 * Data Send and Receive (Interrupt-based)
 */
uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pTxBuffer, uint32_t Len);
uint8_t SPI_ReceiveDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pRxBuffer, uint32_t Len);

/*
 * IRQ Configuration and ISR Handling
 */
void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi);
void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void SPI_IRQHandling(SPI_Handle_t *pHandle);

/*
 * Other Peripheral Control APIs
 */
void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);
void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);
void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);
uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName);
void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx);
void SPI_CloseTransmission(SPI_Handle_t *pSPIHandle);
void SPI_CloseReception(SPI_Handle_t *pSPIHandle);

/*
 * Application Callback (to be implemented by user)
 */
void SPI_ApplicationEventCallback(SPI_Handle_t *pSPIHandle, uint8_t AppEvent);

#endif /* STM32F446XX_SPI_DRIVER_H_ */
```

---

## 8. Step 3: SPI Driver Implementation

### 8.1 Clock Control Function

```c
/*
 * stm32f446xx_spi_driver.c
 */

#include "stm32f446xx_spi_driver.h"

/*********************************************************************
 * @fn          SPI_PeriClockControl
 *
 * @brief       Enables or disables peripheral clock for SPI
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   EnorDi: ENABLE or DISABLE
 *
 * @return      None
 *********************************************************************/
void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi)
{
    if (EnorDi == ENABLE)
    {
        if (pSPIx == SPI1)
            SPI1_PCLK_EN();
        else if (pSPIx == SPI2)
            SPI2_PCLK_EN();
        else if (pSPIx == SPI3)
            SPI3_PCLK_EN();
        else if (pSPIx == SPI4)
            SPI4_PCLK_EN();
    }
    else
    {
        if (pSPIx == SPI1)
            SPI1_PCLK_DI();
        else if (pSPIx == SPI2)
            SPI2_PCLK_DI();
        else if (pSPIx == SPI3)
            SPI3_PCLK_DI();
        else if (pSPIx == SPI4)
            SPI4_PCLK_DI();
    }
}
```

### 8.2 Initialization Function (MOST IMPORTANT)

```c
/*********************************************************************
 * @fn          SPI_Init
 *
 * @brief       Initializes SPI peripheral according to configuration
 *
 * @param[in]   pSPIHandle: Pointer to SPI handle structure
 *
 * @return      None
 *
 * @note        Call this before using any other SPI functions
 *********************************************************************/
void SPI_Init(SPI_Handle_t *pSPIHandle)
{
    // Enable the peripheral clock
    SPI_PeriClockControl(pSPIHandle->pSPIx, ENABLE);
    
    // Configure SPI_CR1 register
    uint32_t tempreg = 0;
    
    /*
     * STEP 1: Configure Device Mode (Master/Slave)
     * ─────────────────────────────────────────────
     * MSTR bit (bit 2): 0 = Slave, 1 = Master
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_DeviceMode << SPI_CR1_MSTR);
    
    /*
     * STEP 2: Configure Bus Configuration
     * ─────────────────────────────────────
     * BIDIMODE (bit 15): 0 = 2-line unidirectional, 1 = 1-line bidirectional
     * RXONLY (bit 10): 0 = Full duplex, 1 = Receive only
     */
    if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD)
    {
        // Full Duplex: BIDIMODE = 0 (2-line mode)
        tempreg &= ~(1 << SPI_CR1_BIDIMODE);
    }
    else if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD)
    {
        // Half Duplex: BIDIMODE = 1 (1-line mode)
        tempreg |= (1 << SPI_CR1_BIDIMODE);
    }
    else if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RXONLY)
    {
        // Simplex RX: BIDIMODE = 0, RXONLY = 1
        tempreg &= ~(1 << SPI_CR1_BIDIMODE);
        tempreg |= (1 << SPI_CR1_RXONLY);
    }
    
    /*
     * STEP 3: Configure Clock Speed (Baud Rate)
     * ──────────────────────────────────────────
     * BR[2:0] bits (bits 5:3): Clock prescaler
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_SclkSpeed << SPI_CR1_BR);
    
    /*
     * STEP 4: Configure Data Frame Format
     * ────────────────────────────────────
     * DFF bit (bit 11): 0 = 8-bit, 1 = 16-bit
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_DFF << SPI_CR1_DFF);
    
    /*
     * STEP 5: Configure Clock Polarity
     * ─────────────────────────────────
     * CPOL bit (bit 1): 0 = Clock LOW when idle, 1 = Clock HIGH when idle
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_CPOL << SPI_CR1_CPOL);
    
    /*
     * STEP 6: Configure Clock Phase
     * ──────────────────────────────
     * CPHA bit (bit 0): 0 = Sample on 1st edge, 1 = Sample on 2nd edge
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_CPHA << SPI_CR1_CPHA);
    
    /*
     * STEP 7: Configure Software Slave Management
     * ────────────────────────────────────────────
     * SSM bit (bit 9): 0 = Hardware NSS, 1 = Software NSS (SSI bit used)
     */
    tempreg |= (pSPIHandle->SPIConfig.SPI_SSM << SPI_CR1_SSM);
    
    // Write configuration to CR1 register
    pSPIHandle->pSPIx->CR1 = tempreg;
}
```

### 8.3 Send Data Function (Blocking)

```c
/*********************************************************************
 * @fn          SPI_SendData
 *
 * @brief       Sends data over SPI (blocking/polling mode)
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   pTxBuffer: Pointer to data buffer
 * @param[in]   Len: Number of bytes to send
 *
 * @return      None
 *
 * @note        This is a BLOCKING function - waits until all data sent
 *********************************************************************/
void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
    while (Len > 0)
    {
        /*
         * STEP 1: Wait until TXE (TX buffer empty) flag is set
         * ─────────────────────────────────────────────────────
         * TXE = 1 means TX buffer is empty and ready for new data
         */
        while (SPI_GetFlagStatus(pSPIx, SPI_TXE_FLAG) == FLAG_RESET);
        
        /*
         * STEP 2: Check data frame format and load data into DR
         * ──────────────────────────────────────────────────────
         */
        if (pSPIx->CR1 & (1 << SPI_CR1_DFF))
        {
            // 16-bit data frame
            pSPIx->DR = *((uint16_t*)pTxBuffer);
            Len -= 2;
            (uint16_t*)pTxBuffer++;
        }
        else
        {
            // 8-bit data frame
            pSPIx->DR = *pTxBuffer;
            Len--;
            pTxBuffer++;
        }
    }
}
```

### 8.4 Receive Data Function (Blocking)

```c
/*********************************************************************
 * @fn          SPI_ReceiveData
 *
 * @brief       Receives data over SPI (blocking/polling mode)
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[out]  pRxBuffer: Pointer to receive buffer
 * @param[in]   Len: Number of bytes to receive
 *
 * @return      None
 *
 * @note        This is a BLOCKING function - waits until all data received
 *********************************************************************/
void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
{
    while (Len > 0)
    {
        /*
         * STEP 1: Wait until RXNE (RX buffer not empty) flag is set
         * ──────────────────────────────────────────────────────────
         * RXNE = 1 means data is available in RX buffer
         */
        while (SPI_GetFlagStatus(pSPIx, SPI_RXNE_FLAG) == FLAG_RESET);
        
        /*
         * STEP 2: Check data frame format and read data from DR
         * ──────────────────────────────────────────────────────
         */
        if (pSPIx->CR1 & (1 << SPI_CR1_DFF))
        {
            // 16-bit data frame
            *((uint16_t*)pRxBuffer) = pSPIx->DR;
            Len -= 2;
            (uint16_t*)pRxBuffer++;
        }
        else
        {
            // 8-bit data frame
            *pRxBuffer = pSPIx->DR;
            Len--;
            pRxBuffer++;
        }
    }
}
```

### 8.5 Helper Functions

```c
/*********************************************************************
 * @fn          SPI_GetFlagStatus
 *
 * @brief       Returns the status of a specific flag
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   FlagName: Flag to check (SPI_TXE_FLAG, SPI_RXNE_FLAG, etc.)
 *
 * @return      FLAG_SET or FLAG_RESET
 *********************************************************************/
uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName)
{
    if (pSPIx->SR & FlagName)
    {
        return FLAG_SET;
    }
    return FLAG_RESET;
}

/*********************************************************************
 * @fn          SPI_PeripheralControl
 *
 * @brief       Enables or disables the SPI peripheral
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   EnOrDi: ENABLE or DISABLE
 *
 * @return      None
 *
 * @note        SPE bit must be set AFTER all configuration is done
 *********************************************************************/
void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
    if (EnOrDi == ENABLE)
    {
        pSPIx->CR1 |= (1 << SPI_CR1_SPE);
    }
    else
    {
        pSPIx->CR1 &= ~(1 << SPI_CR1_SPE);
    }
}

/*********************************************************************
 * @fn          SPI_SSIConfig
 *
 * @brief       Configures SSI bit (Internal Slave Select)
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   EnOrDi: ENABLE or DISABLE
 *
 * @return      None
 *
 * @note        When SSM=1, SSI determines the NSS pin level internally
 *              SSI=1 keeps NSS HIGH (required to prevent MODF error)
 *********************************************************************/
void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
    if (EnOrDi == ENABLE)
    {
        pSPIx->CR1 |= (1 << SPI_CR1_SSI);
    }
    else
    {
        pSPIx->CR1 &= ~(1 << SPI_CR1_SSI);
    }
}

/*********************************************************************
 * @fn          SPI_SSOEConfig
 *
 * @brief       Configures SSOE bit (Slave Select Output Enable)
 *
 * @param[in]   pSPIx: SPI peripheral base address
 * @param[in]   EnOrDi: ENABLE or DISABLE
 *
 * @return      None
 *
 * @note        When SSOE=1, NSS pin is driven LOW when SPI is enabled
 *              Used in hardware NSS mode for single master
 *********************************************************************/
void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
    if (EnOrDi == ENABLE)
    {
        pSPIx->CR2 |= (1 << SPI_CR2_SSOE);
    }
    else
    {
        pSPIx->CR2 &= ~(1 << SPI_CR2_SSOE);
    }
}
```

---

## 9. Testing Your Driver

### 9.1 Basic Loopback Test

Connect MOSI to MISO on the same SPI peripheral:

```c
#include "stm32f446xx.h"
#include "stm32f446xx_spi_driver.h"
#include "stm32f446xx_gpio_driver.h"

int main(void)
{
    // Test data
    char user_data[] = "Hello SPI";
    
    /*
     * STEP 1: Configure GPIO pins for SPI2
     * ─────────────────────────────────────
     * PB13 -> SCLK
     * PB14 -> MISO
     * PB15 -> MOSI
     */
    GPIO_Handle_t SPIPins;
    SPIPins.pGPIOx = GPIOB;
    SPIPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    SPIPins.GPIO_PinConfig.GPIO_PinAltFunMode = 5;  // AF5 for SPI2
    SPIPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    SPIPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    SPIPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
    
    // SCLK
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_13;
    GPIO_Init(&SPIPins);
    
    // MISO
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_14;
    GPIO_Init(&SPIPins);
    
    // MOSI
    SPIPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_15;
    GPIO_Init(&SPIPins);
    
    /*
     * STEP 2: Configure SPI2 peripheral
     * ──────────────────────────────────
     */
    SPI_Handle_t SPI2Handle;
    SPI2Handle.pSPIx = SPI2;
    SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
    SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
    SPI2Handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV8;
    SPI2Handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
    SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
    SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
    SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_EN;  // Software slave management
    
    SPI_Init(&SPI2Handle);
    
    /*
     * STEP 3: Enable SSI to prevent MODF error
     * ─────────────────────────────────────────
     * When SSM=1, we must set SSI=1 to keep internal NSS HIGH
     */
    SPI_SSIConfig(SPI2, ENABLE);
    
    /*
     * STEP 4: Enable SPI2 peripheral
     * ───────────────────────────────
     */
    SPI_PeripheralControl(SPI2, ENABLE);
    
    /*
     * STEP 5: Send data
     * ──────────────────
     */
    SPI_SendData(SPI2, (uint8_t*)user_data, strlen(user_data));
    
    /*
     * STEP 6: Wait until SPI is not busy, then disable
     * ─────────────────────────────────────────────────
     */
    while (SPI_GetFlagStatus(SPI2, SPI_BUSY_FLAG));
    
    SPI_PeripheralControl(SPI2, DISABLE);
    
    while(1);
    
    return 0;
}
```

### 9.2 Communication with Arduino (Slave)

**Master (STM32F446RE):**
```c
void SPI_SendToArduino(void)
{
    char data[] = "Hello Arduino!";
    uint8_t dataLen = strlen(data);
    
    // Enable SPI
    SPI_PeripheralControl(SPI2, ENABLE);
    
    // First send length
    SPI_SendData(SPI2, &dataLen, 1);
    
    // Then send data
    SPI_SendData(SPI2, (uint8_t*)data, dataLen);
    
    // Wait for completion
    while (SPI_GetFlagStatus(SPI2, SPI_BUSY_FLAG));
    
    // Disable SPI
    SPI_PeripheralControl(SPI2, DISABLE);
}
```

**Slave (Arduino):**
```cpp
#include <SPI.h>

volatile boolean received = false;
volatile byte rxBuffer[100];
volatile uint8_t idx = 0;

void setup() {
    Serial.begin(9600);
    
    // Configure as SPI Slave
    pinMode(MISO, OUTPUT);
    SPCR |= _BV(SPE);  // Enable SPI
    SPI.attachInterrupt();
}

ISR(SPI_STC_vect) {
    byte c = SPDR;
    rxBuffer[idx++] = c;
    received = true;
}

void loop() {
    if (received) {
        // Print received data
        for (int i = 0; i < idx; i++) {
            Serial.print((char)rxBuffer[i]);
        }
        Serial.println();
        idx = 0;
        received = false;
    }
}
```

---

## 10. Interrupt-Based SPI

### 10.1 Why Use Interrupts?

```
BLOCKING (POLLING) MODE:
────────────────────────
CPU waits in loop until data transfer complete
• Simple to implement
• Wastes CPU cycles
• Cannot do other tasks during transfer

INTERRUPT MODE:
───────────────
CPU initiates transfer, then does other work
Interrupt fires when transfer complete
• More complex to implement
• CPU efficient
• Can multitask
```

### 10.2 SPI Interrupt Sources

| Interrupt | Flag | Enable Bit | Description |
|-----------|------|------------|-------------|
| TXE | SR.TXE | CR2.TXEIE | TX buffer empty |
| RXNE | SR.RXNE | CR2.RXNEIE | RX buffer not empty |
| Error | SR.OVR/MODF | CR2.ERRIE | Overrun or mode fault |

### 10.3 Interrupt-Based Send Function

```c
uint8_t SPI_SendDataIT(SPI_Handle_t *pSPIHandle, uint8_t *pTxBuffer, uint32_t Len)
{
    uint8_t state = pSPIHandle->TxState;
    
    if (state != SPI_BUSY_IN_TX)
    {
        // 1. Save TX buffer address and length
        pSPIHandle->pTxBuffer = pTxBuffer;
        pSPIHandle->TxLen = Len;
        
        // 2. Mark SPI state as busy
        pSPIHandle->TxState = SPI_BUSY_IN_TX;
        
        // 3. Enable TXEIE to get interrupt when TXE flag is set
        pSPIHandle->pSPIx->CR2 |= (1 << SPI_CR2_TXEIE);
        
        // 4. Data transmission handled by ISR
    }
    
    return state;
}
```

### 10.4 IRQ Handler Implementation

```c
void SPI_IRQHandling(SPI_Handle_t *pHandle)
{
    uint8_t temp1, temp2;
    
    // Check for TXE
    temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_TXE);
    temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_TXEIE);
    
    if (temp1 && temp2)
    {
        // Handle TXE interrupt
        spi_txe_interrupt_handle(pHandle);
    }
    
    // Check for RXNE
    temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_RXNE);
    temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_RXNEIE);
    
    if (temp1 && temp2)
    {
        // Handle RXNE interrupt
        spi_rxne_interrupt_handle(pHandle);
    }
    
    // Check for OVR (Overrun)
    temp1 = pHandle->pSPIx->SR & (1 << SPI_SR_OVR);
    temp2 = pHandle->pSPIx->CR2 & (1 << SPI_CR2_ERRIE);
    
    if (temp1 && temp2)
    {
        // Handle overrun error
        spi_ovr_err_interrupt_handle(pHandle);
    }
}
```

---

## 11. Best Practices

### 11.1 SPI Configuration Checklist

```
Before First Transfer:
─────────────────────
□ Enable peripheral clock
□ Configure GPIO pins for SPI (Alternate Function mode)
□ Configure CR1 register (mode, speed, CPOL, CPHA, etc.)
□ Set SSI=1 if using software slave management
□ Enable SPI peripheral (SPE=1)

Before Each Transfer:
────────────────────
□ Pull slave select LOW (if using hardware NSS)
□ Wait for TXE before writing to DR
□ Wait for RXNE before reading from DR

After Transfer:
───────────────
□ Wait until BSY=0
□ Pull slave select HIGH
□ Optionally disable SPI
```

### 11.2 Common Pitfalls

```c
// MISTAKE 1: Not waiting for TXE before writing
pSPIx->DR = data;  // WRONG - might overwrite previous data

// CORRECT:
while (!(pSPIx->SR & SPI_TXE_FLAG));
pSPIx->DR = data;

// MISTAKE 2: Disabling SPI while busy
SPI_PeripheralControl(pSPIx, DISABLE);  // WRONG - might corrupt transfer

// CORRECT:
while (pSPIx->SR & SPI_BUSY_FLAG);
SPI_PeripheralControl(pSPIx, DISABLE);

// MISTAKE 3: Forgetting SSI when SSM=1
// Results in MODF (Mode Fault) error

// CORRECT:
SPI_SSIConfig(pSPIx, ENABLE);  // Set SSI=1 to keep NSS HIGH internally
```

### 11.3 NSS Pin Management

```
┌─────────────────────────────────────────────────────────────────┐
│                    NSS PIN MANAGEMENT                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  SOFTWARE MANAGEMENT (SSM=1):                                   │
│  ────────────────────────────                                   │
│  • NSS pin not used                                            │
│  • SSI bit controls internal NSS level                         │
│  • Must set SSI=1 in Master mode to avoid MODF                 │
│  • Use GPIO to control slave's SS pin manually                 │
│                                                                 │
│  HARDWARE MANAGEMENT (SSM=0):                                   │
│  ────────────────────────────                                   │
│  • NSS pin driven by hardware                                  │
│  • Set SSOE=1 for single master (drives NSS LOW when SPE=1)    │
│  • Multi-master: NSS used for collision detection              │
│                                                                 │
│  RECOMMENDED FOR BEGINNERS:                                     │
│  • Use SSM=1 (software management)                             │
│  • Set SSI=1                                                   │
│  • Control slave SS with regular GPIO pin                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 12. Troubleshooting Guide

### 12.1 Common Problems and Solutions

| Problem | Possible Cause | Solution |
|---------|----------------|----------|
| No clock on SCK | SPI not enabled | Set SPE=1 |
| MODF error | NSS pulled LOW in master mode | Set SSI=1 when SSM=1 |
| OVR error | Data not read before next arrives | Read DR faster or use DMA |
| Data corruption | CPOL/CPHA mismatch | Match master and slave modes |
| No data received | Wrong bus config | Check RXONLY and BIDIMODE |
| Slow transfer | High prescaler | Reduce BR value |

### 12.2 Debugging Steps

```
1. CHECK CLOCK:
   □ Is peripheral clock enabled?
   □ Use oscilloscope to verify SCK signal
   
2. CHECK GPIO:
   □ Correct alternate function number?
   □ Push-pull output for MOSI and SCK?
   
3. CHECK CONFIGURATION:
   □ Master/Slave mode correct?
   □ CPOL/CPHA match slave device?
   □ Data frame format (8/16 bit) correct?
   
4. CHECK STATUS FLAGS:
   □ TXE set before writing?
   □ RXNE set before reading?
   □ Any error flags set?
   
5. CHECK NSS:
   □ SSM and SSI configured correctly?
   □ Slave select pulled LOW?
```

### 12.3 Using Logic Analyzer

```
What to Check with Logic Analyzer:
──────────────────────────────────
1. SCK frequency - matches your configuration?
2. SCK idle state - matches CPOL setting?
3. Data edges - matches CPHA setting?
4. SS signal - LOW during transfer?
5. MOSI data - correct bit order?
6. MISO data - slave responding?
```

---

## Summary

### Key Points to Remember

1. **SPI is synchronous** - Master always generates clock
2. **Full duplex** - Send and receive happen simultaneously
3. **4 modes** - Determined by CPOL and CPHA
4. **Enable clock first** - Before any configuration
5. **Configure before enabling** - Set all bits, then SPE=1
6. **Check TXE before write** - Prevents data loss
7. **Check RXNE before read** - Ensures valid data
8. **Wait for BSY=0** - Before disabling SPI
9. **NSS management** - Use SSM=1, SSI=1 for simplicity

### Driver Development Checklist

```
□ Step 1: Study reference manual
□ Step 2: Add SPI structures to MCU header
□ Step 3: Add base addresses and pointers
□ Step 4: Add clock enable macros
□ Step 5: Add bit position definitions
□ Step 6: Create configuration structure
□ Step 7: Create handle structure
□ Step 8: Implement clock control function
□ Step 9: Implement init function
□ Step 10: Implement send function (blocking)
□ Step 11: Implement receive function (blocking)
□ Step 12: Implement helper functions
□ Step 13: Test with loopback
□ Step 14: Test with external device
□ Step 15: Add interrupt support (optional)
```

---

*This guide is part of the STM32F446RE_Drivers project.*
*Reference: RM0390 - STM32F446xx Reference Manual, Chapter 28: SPI*

