# Complete I2C Driver Development Guide for STM32F446RE

## A Step-by-Step Guide for Absolute Beginners

---

## Table of Contents

1. [Introduction to I2C](#1-introduction-to-i2c)
2. [I2C Protocol Fundamentals](#2-i2c-protocol-fundamentals)
3. [I2C Hardware Concepts](#3-i2c-hardware-concepts)
4. [STM32F446RE I2C Peripheral](#4-stm32f446re-i2c-peripheral)
5. [I2C Register Details](#5-i2c-register-details)
6. [Driver Architecture](#6-driver-architecture)
7. [Step-by-Step Implementation](#7-step-by-step-implementation)
8. [Interrupt-Based I2C](#8-interrupt-based-i2c)
9. [Error Handling](#9-error-handling)
10. [Testing Your Driver](#10-testing-your-driver)
11. [Best Practices](#11-best-practices)
12. [Troubleshooting](#12-troubleshooting)

---

## 1. Introduction to I2C

### What is I2C?

**I2C (Inter-Integrated Circuit)**, pronounced "I-squared-C" or "I-two-C", is a synchronous, multi-master, multi-slave serial communication protocol invented by Philips Semiconductor (now NXP).

### Why Learn I2C?

I2C is everywhere in embedded systems:
- **Sensors**: Temperature, humidity, pressure, accelerometers, gyroscopes
- **EEPROMs**: Data storage
- **RTCs**: Real-time clocks
- **Displays**: OLED, LCD controllers
- **ADCs/DACs**: Analog-to-digital and digital-to-analog converters
- **IO Expanders**: Additional GPIO pins

### I2C vs Other Protocols

```
┌─────────────┬─────────┬─────────┬─────────────┐
│   Feature   │   I2C   │   SPI   │    UART     │
├─────────────┼─────────┼─────────┼─────────────┤
│ Wires       │ 2       │ 4+      │ 2           │
│ Speed       │ Up to   │ Up to   │ Up to       │
│             │ 3.4Mbps │ 50Mbps  │ 5Mbps       │
│ Multi-slave │ Yes     │ Yes     │ No          │
│ Multi-master│ Yes     │ No      │ No          │
│ Duplex      │ Half    │ Full    │ Full        │
│ Addressing  │ Built-in│ CS pins │ N/A         │
│ Complexity  │ Medium  │ Low     │ Low         │
└─────────────┴─────────┴─────────┴─────────────┘
```

---

## 2. I2C Protocol Fundamentals

### The Two-Wire Interface

I2C uses only **two wires** for communication:

```
        ┌─────────────────────────────────────────────────┐
   VCC ─┤                                                 │
        │    ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐  │
        │    │ Rp  │     │ Rp  │     │     │     │     │  │
        │    └──┬──┘     └──┬──┘     │     │     │     │  │
        │       │           │        │     │     │     │  │
   SDA ─┼───────┴───────────┼────────┤ M   │─────┤ S1  │──┼─────
        │                   │        │ A   │     │ L   │  │
   SCL ─┼───────────────────┴────────┤ S   │─────┤ A   │──┼─────
        │                            │ T   │     │ V   │  │
   GND ─┼────────────────────────────┤ E   │─────┤ E   │──┼─────
        │                            │ R   │     │     │  │
        │                            └─────┘     └─────┘  │
        └─────────────────────────────────────────────────┘
        
   SDA = Serial Data Line (bidirectional)
   SCL = Serial Clock Line (generated by master)
   Rp  = Pull-up Resistors (typically 4.7kΩ)
```

### Why Pull-up Resistors?

I2C uses **open-drain** outputs:
- Devices can only pull lines LOW
- Pull-up resistors pull lines HIGH when released
- This allows multiple devices to share the bus safely

```
  Without device pulling:     Device pulling LOW:
  
      VCC                         VCC
       │                           │
      [Rp]                        [Rp]
       │                           │
  ─────┴───── HIGH            ────┬───── LOW
                                  │
                                 ─┴─ (transistor ON)
                                 GND
```

### I2C Speed Modes

```
┌────────────────┬─────────────┬─────────────────────┐
│     Mode       │    Speed    │    Common Use       │
├────────────────┼─────────────┼─────────────────────┤
│ Standard Mode  │ 100 kHz     │ Most sensors/EEPROMs│
│ Fast Mode      │ 400 kHz     │ Higher speed devices│
│ Fast Mode Plus │ 1 MHz       │ High-speed sensors  │
│ High Speed     │ 3.4 MHz     │ Special applications│
└────────────────┴─────────────┴─────────────────────┘
```

### I2C Addressing

Every I2C slave has a **unique 7-bit address** (or 10-bit in extended mode):

```
  7-bit Address Format:
  ┌───┬───┬───┬───┬───┬───┬───┬─────┐
  │ A6│ A5│ A4│ A3│ A2│ A1│ A0│ R/W │
  └───┴───┴───┴───┴───┴───┴───┴─────┘
   MSB                     LSB
   
  R/W bit: 0 = Write, 1 = Read
  
  Example: Slave address 0x48, Write operation
  Address byte = (0x48 << 1) | 0 = 0x90
  
  Example: Slave address 0x48, Read operation
  Address byte = (0x48 << 1) | 1 = 0x91
```

### I2C Data Frame Structure

```
Complete I2C Transaction (Master Write):

         START    ADDRESS + W    ACK     DATA      ACK      STOP
           │           │          │        │         │         │
           ▼           ▼          ▼        ▼         ▼         ▼
    ───┐   ┌──────────────┐  ┌─┐  ┌────────────┐  ┌─┐     ┌───────
SDA    └───┤  A6...A0  0  ├──┤ ├──┤ D7...D0    ├──┤ ├─────┤
    ───────┴──────────────┴──┴─┴──┴────────────┴──┴─┴─────┴───────
       ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐
SCL ───┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └────────
        1   2   3   4   5   6   7   8   9   1   2   3...8   9
        
        └─────── 8 bits ──────┘ │   └─── 8 bits ───┘  │
                               ACK                   ACK
```

### START and STOP Conditions

```
START Condition:                    STOP Condition:
SDA goes LOW while SCL is HIGH      SDA goes HIGH while SCL is HIGH

        ┌───┐                              ┌───────
SDA ────┘   └───────                ───────┘
    ────────┐                          ┌───────────
SCL         └───────                ───┘

    "I want to talk"               "I'm done talking"
```

### Acknowledge (ACK) and Not Acknowledge (NACK)

```
After every byte, receiver must respond:

ACK (Acknowledge):                  NACK (Not Acknowledge):
Receiver pulls SDA LOW              Receiver leaves SDA HIGH

    ─────┐     ┌─────                ─────────────────
SDA      └─────┘                     
         ┌─────┐                          ┌─────┐
SCL ─────┘     └─────                ─────┘     └─────
         
    "Got it, send more"             "Stop or error"
```

---

## 3. I2C Hardware Concepts

### Master vs Slave

```
┌──────────────────────────────────────────────────────────────┐
│                        I2C BUS                               │
│                                                              │
│     ┌─────────┐      ┌─────────┐      ┌─────────┐           │
│     │ MASTER  │      │ SLAVE 1 │      │ SLAVE 2 │           │
│     │  (MCU)  │      │ (Sensor)│      │ (EEPROM)│           │
│     │         │      │         │      │         │           │
│     │ Controls│      │ Addr:   │      │ Addr:   │           │
│     │  clock  │      │  0x48   │      │  0x50   │           │
│     └────┬────┘      └────┬────┘      └────┬────┘           │
│          │                │                │                 │
│  SDA ════╪════════════════╪════════════════╪══════════       │
│  SCL ════╪════════════════╪════════════════╪══════════       │
│          │                │                │                 │
└──────────┴────────────────┴────────────────┴─────────────────┘

MASTER:                          SLAVE:
- Initiates communication        - Responds to master
- Generates clock (SCL)          - Has unique address
- Generates START/STOP           - Sends ACK/NACK
- Controls data direction        - Can stretch clock
```

### Clock Stretching

Slaves can hold SCL LOW to pause communication:

```
Normal Transaction:
    ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐
SCL ┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─
    Fast, consistent timing

With Clock Stretching:
    ┌─┐ ┌─┐ ┌───────┐ ┌─┐ ┌─┐
SCL ┘ └─┘ └─┘       └─┘ └─┘ └─
              ▲
              │
        Slave holds LOW
        (needs more time)
```

### Repeated START

Used to change direction without releasing the bus:

```
Normal: START → Address+W → Data → STOP → START → Address+R → Data → STOP

With Repeated START:
START → Address+W → Data → REPEATED START → Address+R → Data → STOP
                           │
                           └── No STOP between transactions
                               (keeps bus ownership)
```

---

## 4. STM32F446RE I2C Peripheral

### I2C Instances

STM32F446RE has **three I2C peripherals** plus one Fast-mode Plus:

```
┌────────┬───────────┬───────────────────────────────────┐
│ I2C    │ Bus       │ Available Pins                    │
├────────┼───────────┼───────────────────────────────────┤
│ I2C1   │ APB1      │ SCL: PB6, PB8                     │
│        │           │ SDA: PB7, PB9                     │
├────────┼───────────┼───────────────────────────────────┤
│ I2C2   │ APB1      │ SCL: PB10, PF1, PH4               │
│        │           │ SDA: PB11, PF0, PH5               │
├────────┼───────────┼───────────────────────────────────┤
│ I2C3   │ APB1      │ SCL: PA8, PH7                     │
│        │           │ SDA: PC9, PH8                     │
├────────┼───────────┼───────────────────────────────────┤
│FMPI2C1 │ APB1      │ SCL: PC6, PD12, PD14, PF14        │
│        │           │ SDA: PC7, PD13, PD15, PF15        │
│        │           │ (Fast-mode Plus up to 1MHz)       │
└────────┴───────────┴───────────────────────────────────┘
```

### I2C Block Diagram

```
                    ┌──────────────────────────────────────┐
                    │            I2C Peripheral            │
                    │                                      │
 APB1 Bus ─────────►│  ┌─────────────────────────────┐    │
                    │  │      Control Logic          │    │
                    │  │  ┌─────────┐  ┌──────────┐  │    │
                    │  │  │  Clock  │  │ Address  │  │    │
                    │  │  │ Control │  │ Matching │  │    │
                    │  │  └────┬────┘  └────┬─────┘  │    │
                    │  │       │            │        │    │
                    │  │  ┌────▼────────────▼─────┐  │    │
                    │  │  │    State Machine      │  │    │
                    │  │  │  (Master/Slave modes) │  │    │
                    │  │  └───────────┬───────────┘  │    │
                    │  └──────────────┼──────────────┘    │
                    │                 │                    │
                    │  ┌──────────────▼──────────────┐    │
                    │  │         Data Register       │    │────► SDA
                    │  │            (DR)             │    │
                    │  └─────────────────────────────┘    │
                    │                                      │
                    │  ┌─────────────────────────────┐    │
                    │  │      Clock Generator        │────┼───► SCL
                    │  │         (CCR)               │    │
                    │  └─────────────────────────────┘    │
                    │                                      │
                    └──────────────────────────────────────┘
```

---

## 5. I2C Register Details

### I2C Register Map

```
┌──────────┬────────────┬──────────────────────────────────┐
│ Offset   │  Register  │         Description              │
├──────────┼────────────┼──────────────────────────────────┤
│ 0x00     │  CR1       │ Control Register 1               │
│ 0x04     │  CR2       │ Control Register 2               │
│ 0x08     │  OAR1      │ Own Address Register 1           │
│ 0x0C     │  OAR2      │ Own Address Register 2           │
│ 0x10     │  DR        │ Data Register                    │
│ 0x14     │  SR1       │ Status Register 1                │
│ 0x18     │  SR2       │ Status Register 2                │
│ 0x1C     │  CCR       │ Clock Control Register           │
│ 0x20     │  TRISE     │ Rise Time Register               │
│ 0x24     │  FLTR      │ Filter Register                  │
└──────────┴────────────┴──────────────────────────────────┘
```

### CR1 - Control Register 1

```
  31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│          Reserved             │SWR│   │   │   │   │   │   │   │
│                               │ST │   │   │   │   │   │   │   │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
                                 │
                                 └── SWRST: Software Reset

  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│   │ALR│POS│PEC│   │   │ENG│NOA│STP│STA│   │   │   │SML│   │ PE│
│   │ T │   │   │   │   │ C │CK │ P │RT │   │   │   │BUS│   │   │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
 │   │   │   │       │   │    │   │       │           │       │
 │   │   │   │       │   │    │   │       │           │       └── PE: Peripheral Enable
 │   │   │   │       │   │    │   │       │           │           0 = Disabled
 │   │   │   │       │   │    │   │       │           │           1 = Enabled
 │   │   │   │       │   │    │   │       │           │
 │   │   │   │       │   │    │   │       │           └── SMBUS: SMBus mode
 │   │   │   │       │   │    │   │       │               0 = I2C mode
 │   │   │   │       │   │    │   │       │
 │   │   │   │       │   │    │   │       └── START: Start generation
 │   │   │   │       │   │    │   │           Master: 1 = Generate START
 │   │   │   │       │   │    │   │
 │   │   │   │       │   │    │   └── STOP: Stop generation
 │   │   │   │       │   │    │       Master: 1 = Generate STOP
 │   │   │   │       │   │    │
 │   │   │   │       │   │    └── ACK: Acknowledge enable
 │   │   │   │       │   │        0 = No ACK returned
 │   │   │   │       │   │        1 = ACK returned after byte received
 │   │   │   │       │   │
 │   │   │   │       │   └── ENGC: General call enable
 │   │   │   │       │
 │   │   │   │       └── PEC: Packet Error Checking
 │   │   │   │
 │   │   │   └── POS: ACK/PEC Position
 │   │   │
 │   │   └── ALERT: SMBus Alert
 │   │
 │   └── Reserved
```

### CR2 - Control Register 2

```
  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│   │   │   │LST│DMR│DMT│ITB│ITE│ITE│   │         FREQ          │
│   │   │   │   │ X │ X │UF │VT │RR │   │                       │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
             │   │   │   │   │   │       │
             │   │   │   │   │   │       └── FREQ[5:0]: Peripheral clock frequency
             │   │   │   │   │   │           Value in MHz (e.g., 16 for 16MHz)
             │   │   │   │   │   │
             │   │   │   │   │   └── ITERREN: Error interrupt enable
             │   │   │   │   │
             │   │   │   │   └── ITEVTEN: Event interrupt enable
             │   │   │   │
             │   │   │   └── ITBUFEN: Buffer interrupt enable
             │   │   │
             │   │   └── DMAEN: DMA requests enable
             │   │
             │   └── LAST: DMA last transfer
             │
             └── Reserved
```

### SR1 - Status Register 1

```
  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│SML│   │TMO│   │PEC│OVR│ AF│ARL│BER│TxE│RxN│   │AD1│BTF│ADD│ SB│
│BUS│   │UT │   │ERR│   │   │ O │ R │   │ E │   │ 0 │   │ R │   │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
 │       │       │   │   │   │   │   │   │       │   │   │   │
 │       │       │   │   │   │   │   │   │       │   │   │   └── SB: Start bit (Master)
 │       │       │   │   │   │   │   │   │       │   │   │       1 = Start condition generated
 │       │       │   │   │   │   │   │   │       │   │   │
 │       │       │   │   │   │   │   │   │       │   │   └── ADDR: Address sent/matched
 │       │       │   │   │   │   │   │   │       │   │       Master: Address sent
 │       │       │   │   │   │   │   │   │       │   │       Slave: Address matched
 │       │       │   │   │   │   │   │   │       │   │
 │       │       │   │   │   │   │   │   │       │   └── BTF: Byte transfer finished
 │       │       │   │   │   │   │   │   │       │
 │       │       │   │   │   │   │   │   │       └── ADD10: 10-bit header sent
 │       │       │   │   │   │   │   │   │
 │       │       │   │   │   │   │   │   └── RxNE: Data register not empty
 │       │       │   │   │   │   │   │       1 = Data register contains received data
 │       │       │   │   │   │   │   │
 │       │       │   │   │   │   │   └── TxE: Data register empty
 │       │       │   │   │   │   │       1 = Data register empty (transmit)
 │       │       │   │   │   │   │
 │       │       │   │   │   │   └── BERR: Bus error
 │       │       │   │   │   │       1 = Misplaced START/STOP
 │       │       │   │   │   │
 │       │       │   │   │   └── ARLO: Arbitration lost
 │       │       │   │   │       1 = Arbitration lost (multi-master)
 │       │       │   │   │
 │       │       │   │   └── AF: Acknowledge failure
 │       │       │   │       1 = No ACK received
 │       │       │   │
 │       │       │   └── OVR: Overrun/Underrun
 │       │       │
 │       │       └── PECERR: PEC Error
 │       │
 │       └── TIMEOUT: Timeout error
 │
 └── SMBALERT: SMBus Alert
```

### SR2 - Status Register 2

```
  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│            PEC[7:0]           │DUA│SMB│   │GEN│   │TRA│BSY│MSL│
│                               │ LF│HST│   │CLL│   │   │   │   │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
                                 │   │       │       │   │   │
                                 │   │       │       │   │   └── MSL: Master/Slave
                                 │   │       │       │   │       0 = Slave mode
                                 │   │       │       │   │       1 = Master mode
                                 │   │       │       │   │
                                 │   │       │       │   └── BUSY: Bus busy
                                 │   │       │       │       1 = Communication ongoing
                                 │   │       │       │
                                 │   │       │       └── TRA: Transmitter/Receiver
                                 │   │       │           0 = Data bytes received
                                 │   │       │           1 = Data bytes transmitted
                                 │   │       │
                                 │   │       └── GENCALL: General call received
                                 │   │
                                 │   └── SMBHOST: SMBus host header
                                 │
                                 └── DUALF: Dual flag (OAR2 matched)
```

### CCR - Clock Control Register

```
  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┴───┴───┐
│F/S│DTY│   │   │                  CCR[11:0]                    │
└───┴───┴───┴───┴───────────────────────────────────────────────┘
 │   │                           │
 │   │                           └── CCR: Clock control
 │   │                               Controls SCL clock in master mode
 │   │
 │   └── DUTY: Fast mode duty cycle
 │       0 = t_low/t_high = 2
 │       1 = t_low/t_high = 16/9
 │
 └── F/S: Master mode selection
     0 = Standard mode (up to 100kHz)
     1 = Fast mode (up to 400kHz)
```

### CCR Calculation

```
For Standard Mode (100 kHz):
  CCR = f_PCLK1 / (2 × f_SCL)
  Example: f_PCLK1 = 16MHz, f_SCL = 100kHz
  CCR = 16,000,000 / (2 × 100,000) = 80

For Fast Mode with DUTY=0 (t_low/t_high = 2):
  CCR = f_PCLK1 / (3 × f_SCL)
  Example: f_PCLK1 = 16MHz, f_SCL = 400kHz
  CCR = 16,000,000 / (3 × 400,000) = 13

For Fast Mode with DUTY=1 (t_low/t_high = 16/9):
  CCR = f_PCLK1 / (25 × f_SCL)
  Example: f_PCLK1 = 16MHz, f_SCL = 400kHz
  CCR = 16,000,000 / (25 × 400,000) = 1.6 ≈ 2
```

### TRISE - Rise Time Register

```
  15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│                 Reserved                  │    TRISE[5:0]     │
└───────────────────────────────────────────┴───────────────────┘
                                                     │
                                                     └── Maximum rise time

TRISE Calculation:
  Standard Mode: TRISE = (f_PCLK1 × t_rise_max) + 1
                 t_rise_max = 1000ns = 1µs
                 TRISE = (16MHz × 1µs) + 1 = 17

  Fast Mode:     TRISE = (f_PCLK1 × t_rise_max) + 1
                 t_rise_max = 300ns = 0.3µs
                 TRISE = (16MHz × 0.3µs) + 1 = 5.8 ≈ 6
```

---

## 6. Driver Architecture

### File Structure

```
drivers/
├── inc/
│   ├── stm32f446xx.h              ← MCU header (register definitions)
│   ├── stm32f446xx_i2c_driver.h   ← I2C driver header
│   └── stm32f446xx_rcc_driver.h   ← RCC driver (for clock values)
└── src/
    ├── stm32f446xx_i2c_driver.c   ← I2C driver implementation
    └── stm32f446xx_rcc_driver.c   ← RCC driver implementation
```

### Configuration Structure

```c
/*
 * Configuration structure for I2C peripheral
 */
typedef struct
{
    uint32_t I2C_SCLSpeed;      // Clock speed (Standard/Fast mode)
    uint8_t  I2C_DeviceAddress; // Own address (when slave)
    uint8_t  I2C_AckControl;    // ACK enable/disable
    uint8_t  I2C_FMDutyCycle;   // Fast mode duty cycle
} I2C_Config_t;
```

### Handle Structure

```c
/*
 * Handle structure for I2C peripheral
 */
typedef struct
{
    I2C_RegDef_t *pI2Cx;        // Base address of I2C peripheral
    I2C_Config_t I2C_Config;    // Configuration settings
    
    // For interrupt-driven communication:
    uint8_t      *pTxBuffer;    // Pointer to TX buffer
    uint8_t      *pRxBuffer;    // Pointer to RX buffer
    uint32_t     TxLen;         // Bytes remaining to transmit
    uint32_t     RxLen;         // Bytes remaining to receive
    uint8_t      TxRxState;     // Communication state
    uint8_t      DevAddr;       // Slave device address
    uint32_t     RxSize;        // Total bytes to receive
    uint8_t      Sr;            // Repeated START flag
} I2C_Handle_t;
```

### Why This Structure?

```
┌──────────────────────────────────────────────────────────────┐
│                    I2C_Handle_t                              │
│                                                              │
│  ┌─────────────┐     Points to actual hardware              │
│  │   pI2Cx ────┼───────► I2C1 (0x40005400)                  │
│  └─────────────┘         I2C2 (0x40005800)                  │
│                          I2C3 (0x40005C00)                  │
│                                                              │
│  ┌─────────────────────────────────────────┐                │
│  │          I2C_Config (Settings)          │                │
│  │  ┌─────────────────┬──────────────┐     │                │
│  │  │ I2C_SCLSpeed    │ 100000/400000│     │                │
│  │  │ I2C_DeviceAddress│ e.g., 0x61 │     │                │
│  │  │ I2C_AckControl  │ ENABLE/DISABLE│    │                │
│  │  │ I2C_FMDutyCycle │ DUTY_2/16_9  │     │                │
│  │  └─────────────────┴──────────────┘     │                │
│  └─────────────────────────────────────────┘                │
│                                                              │
│  ┌─────────────────────────────────────────┐                │
│  │      Interrupt State (Runtime)          │                │
│  │  ┌─────────────┬───────────────────┐    │                │
│  │  │ pTxBuffer   │ → Application data│    │                │
│  │  │ pRxBuffer   │ → Receive buffer  │    │                │
│  │  │ TxLen/RxLen │ Remaining bytes   │    │                │
│  │  │ TxRxState   │ READY/BUSY_TX/RX  │    │                │
│  │  │ DevAddr     │ Target slave addr │    │                │
│  │  │ Sr          │ Repeated START?   │    │                │
│  │  └─────────────┴───────────────────┘    │                │
│  └─────────────────────────────────────────┘                │
└──────────────────────────────────────────────────────────────┘
```

---

## 7. Step-by-Step Implementation

### Step 1: Define Configuration Macros

```c
/*
 * @I2C_SCLSpeed - Clock speed options
 */
#define I2C_SCL_SPEED_SM    100000   // Standard mode: 100 kHz
#define I2C_SCL_SPEED_FM4K  400000   // Fast mode: 400 kHz
#define I2C_SCL_SPEED_FM2K  200000   // Fast mode: 200 kHz

/*
 * @I2C_AckControl - Acknowledge control
 */
#define I2C_ACK_ENABLE      1
#define I2C_ACK_DISABLE     0

/*
 * @I2C_FMDutyCycle - Fast mode duty cycle
 */
#define I2C_FM_DUTY_2       0   // t_low/t_high = 2
#define I2C_FM_DUTY_16_9    1   // t_low/t_high = 16/9
```

### Step 2: Define Status Flags

```c
/*
 * I2C Status Register flags
 */
#define I2C_FLAG_SB         (1 << I2C_SR1_SB)      // Start bit
#define I2C_FLAG_ADDR       (1 << I2C_SR1_ADDR)    // Address sent/matched
#define I2C_FLAG_BTF        (1 << I2C_SR1_BTF)     // Byte transfer finished
#define I2C_FLAG_ADD10      (1 << I2C_SR1_ADD10)   // 10-bit header sent
#define I2C_FLAG_STOPF      (1 << I2C_SR1_STOPF)   // Stop detected
#define I2C_FLAG_RXNE       (1 << I2C_SR1_RXNE)    // RX not empty
#define I2C_FLAG_TXE        (1 << I2C_SR1_TXE)     // TX empty
#define I2C_FLAG_BERR       (1 << I2C_SR1_BERR)    // Bus error
#define I2C_FLAG_ARLO       (1 << I2C_SR1_ARLO)    // Arbitration lost
#define I2C_FLAG_AF         (1 << I2C_SR1_AF)      // ACK failure
#define I2C_FLAG_OVR        (1 << I2C_SR1_OVR)     // Overrun/Underrun
#define I2C_FLAG_TIMEOUT    (1 << I2C_SR1_TIMEOUT) // Timeout
```

### Step 3: Implement Clock Control

```c
void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx, uint8_t EnorDi)
{
    if(EnorDi == ENABLE)
    {
        if(pI2Cx == I2C1)
        {
            I2C1_PCLK_EN();  // Enable I2C1 clock
        }
        else if(pI2Cx == I2C2)
        {
            I2C2_PCLK_EN();  // Enable I2C2 clock
        }
        else if(pI2Cx == I2C3)
        {
            I2C3_PCLK_EN();  // Enable I2C3 clock
        }
    }
    else
    {
        if(pI2Cx == I2C1)
        {
            I2C1_PCLK_DI();  // Disable I2C1 clock
        }
        else if(pI2Cx == I2C2)
        {
            I2C2_PCLK_DI();  // Disable I2C2 clock
        }
        else if(pI2Cx == I2C3)
        {
            I2C3_PCLK_DI();  // Disable I2C3 clock
        }
    }
}
```

### Step 4: Implement Initialization

```c
void I2C_Init(I2C_Handle_t *pI2CHandle)
{
    uint32_t tempreg = 0;
    
    // 1. Enable the peripheral clock
    I2C_PeriClockControl(pI2CHandle->pI2Cx, ENABLE);
    
    // 2. Configure ACK control in CR1
    tempreg = 0;
    tempreg |= (pI2CHandle->I2C_Config.I2C_AckControl << I2C_CR1_ACK);
    pI2CHandle->pI2Cx->CR1 = tempreg;
    
    // 3. Configure FREQ field in CR2
    tempreg = 0;
    tempreg = RCC_GetPCLK1Value() / 1000000U;  // Get APB1 freq in MHz
    pI2CHandle->pI2Cx->CR2 = (tempreg & 0x3F); // Mask to 6 bits
    
    // 4. Configure own address (for slave mode)
    tempreg = 0;
    tempreg |= (pI2CHandle->I2C_Config.I2C_DeviceAddress << 1);
    tempreg |= (1 << 14);  // Bit 14 should always be 1
    pI2CHandle->pI2Cx->OAR1 = tempreg;
    
    // 5. Configure CCR (Clock Control Register)
    tempreg = 0;
    uint16_t ccr_value = 0;
    
    if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
    {
        // Standard mode
        ccr_value = RCC_GetPCLK1Value() / (2 * pI2CHandle->I2C_Config.I2C_SCLSpeed);
        tempreg |= (ccr_value & 0xFFF);
    }
    else
    {
        // Fast mode
        tempreg |= (1 << 15);  // Set F/S bit for fast mode
        tempreg |= (pI2CHandle->I2C_Config.I2C_FMDutyCycle << 14);
        
        if(pI2CHandle->I2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2)
        {
            ccr_value = RCC_GetPCLK1Value() / (3 * pI2CHandle->I2C_Config.I2C_SCLSpeed);
        }
        else
        {
            ccr_value = RCC_GetPCLK1Value() / (25 * pI2CHandle->I2C_Config.I2C_SCLSpeed);
        }
        tempreg |= (ccr_value & 0xFFF);
    }
    pI2CHandle->pI2Cx->CCR = tempreg;
    
    // 6. Configure TRISE
    if(pI2CHandle->I2C_Config.I2C_SCLSpeed <= I2C_SCL_SPEED_SM)
    {
        // Standard mode: t_rise = 1000ns
        tempreg = (RCC_GetPCLK1Value() / 1000000U) + 1;
    }
    else
    {
        // Fast mode: t_rise = 300ns
        tempreg = ((RCC_GetPCLK1Value() * 300) / 1000000000U) + 1;
    }
    pI2CHandle->pI2Cx->TRISE = (tempreg & 0x3F);
}
```

### Step 5: Helper Functions

```c
// Generate START condition
static void I2C_GenerateStartCondition(I2C_RegDef_t *pI2Cx)
{
    pI2Cx->CR1 |= (1 << I2C_CR1_START);
}

// Generate STOP condition
void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx)
{
    pI2Cx->CR1 |= (1 << I2C_CR1_STOP);
}

// Send address with Write bit (0)
static void I2C_ExecuteAddressPhaseWrite(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
{
    SlaveAddr = SlaveAddr << 1;
    SlaveAddr &= ~(1);  // Clear R/W bit (Write = 0)
    pI2Cx->DR = SlaveAddr;
}

// Send address with Read bit (1)
static void I2C_ExecuteAddressPhaseRead(I2C_RegDef_t *pI2Cx, uint8_t SlaveAddr)
{
    SlaveAddr = SlaveAddr << 1;
    SlaveAddr |= 1;  // Set R/W bit (Read = 1)
    pI2Cx->DR = SlaveAddr;
}

// Clear ADDR flag (read SR1 then SR2)
static void I2C_ClearADDRFlag(I2C_Handle_t *pI2CHandle)
{
    uint32_t dummy_read;
    
    // Check device mode
    if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
    {
        // Master mode
        if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
        {
            if(pI2CHandle->RxSize == 1)
            {
                // Disable ACK before clearing ADDR for single byte reception
                I2C_ManageAcking(pI2CHandle->pI2Cx, DISABLE);
            }
        }
    }
    
    // Clear ADDR by reading SR1 then SR2
    dummy_read = pI2CHandle->pI2Cx->SR1;
    dummy_read = pI2CHandle->pI2Cx->SR2;
    (void)dummy_read;  // Avoid unused variable warning
}

// Get flag status
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName)
{
    if(pI2Cx->SR1 & FlagName)
    {
        return FLAG_SET;
    }
    return FLAG_RESET;
}

// Enable/Disable ACK
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t EnorDi)
{
    if(EnorDi == ENABLE)
    {
        pI2Cx->CR1 |= (1 << I2C_CR1_ACK);
    }
    else
    {
        pI2Cx->CR1 &= ~(1 << I2C_CR1_ACK);
    }
}

// Enable/Disable peripheral
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi)
{
    if(EnOrDi == ENABLE)
    {
        pI2Cx->CR1 |= (1 << I2C_CR1_PE);
    }
    else
    {
        pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
    }
}
```

### Step 6: Master Send Data (Blocking)

```c
void I2C_MasterSendData(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, 
                        uint32_t Len, uint8_t SlaveAddr, uint8_t Sr)
{
    // 1. Generate START condition
    I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
    
    // 2. Wait for SB flag (START bit set)
    //    Note: SCL is stretched (held LOW) until SB is cleared
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));
    
    // 3. Send slave address with Write bit
    I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, SlaveAddr);
    
    // 4. Wait for ADDR flag (address phase complete)
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));
    
    // 5. Clear ADDR flag
    //    Note: SCL is stretched until ADDR is cleared
    I2C_ClearADDRFlag(pI2CHandle);
    
    // 6. Send data bytes
    while(Len > 0)
    {
        // Wait for TXE (transmit buffer empty)
        while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE));
        
        // Write data to DR
        pI2CHandle->pI2Cx->DR = *pTxBuffer;
        pTxBuffer++;
        Len--;
    }
    
    // 7. Wait for TXE and BTF before generating STOP
    //    TXE=1, BTF=1 means both shift register and DR are empty
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TXE));
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_BTF));
    
    // 8. Generate STOP condition (unless repeated START requested)
    if(Sr == I2C_DISABLE_SR)
    {
        I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
    }
}
```

### Step 7: Master Receive Data (Blocking)

```c
void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer,
                           uint8_t Len, uint8_t SlaveAddr, uint8_t Sr)
{
    // 1. Generate START condition
    I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
    
    // 2. Wait for SB flag
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));
    
    // 3. Send slave address with Read bit
    I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, SlaveAddr);
    
    // 4. Wait for ADDR flag
    while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));
    
    // 5. Handle based on number of bytes to receive
    if(Len == 1)
    {
        // Single byte reception
        
        // Disable ACK
        I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);
        
        // Clear ADDR flag
        I2C_ClearADDRFlag(pI2CHandle);
        
        // Wait for RXNE
        while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE));
        
        // Generate STOP
        if(Sr == I2C_DISABLE_SR)
        {
            I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
        }
        
        // Read data
        *pRxBuffer = pI2CHandle->pI2Cx->DR;
    }
    else if(Len > 1)
    {
        // Multiple byte reception
        
        // Clear ADDR flag
        I2C_ClearADDRFlag(pI2CHandle);
        
        // Read bytes
        for(uint32_t i = Len; i > 0; i--)
        {
            // Wait for RXNE
            while(!I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_RXNE));
            
            if(i == 2)
            {
                // Last 2 bytes remaining - disable ACK
                I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_DISABLE);
                
                // Generate STOP
                if(Sr == I2C_DISABLE_SR)
                {
                    I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
                }
            }
            
            // Read data
            *pRxBuffer = pI2CHandle->pI2Cx->DR;
            pRxBuffer++;
        }
    }
    
    // Re-enable ACK if it was enabled in config
    if(pI2CHandle->I2C_Config.I2C_AckControl == I2C_ACK_ENABLE)
    {
        I2C_ManageAcking(pI2CHandle->pI2Cx, I2C_ACK_ENABLE);
    }
}
```

---

## 8. Interrupt-Based I2C

### Why Use Interrupts?

```
Polling (Blocking):              Interrupt-Driven:
┌─────────────────┐              ┌─────────────────┐
│  Start I2C TX   │              │  Start I2C TX   │
└────────┬────────┘              └────────┬────────┘
         │                                │
         ▼                                ▼
┌─────────────────┐              ┌─────────────────┐
│ Wait for TXE... │◄─────┐       │ Enable TXE IRQ  │
│ (CPU blocked)   │      │       └────────┬────────┘
└────────┬────────┘      │                │
         │ Flag set      │                ▼
         ▼               │       ┌─────────────────┐
┌─────────────────┐      │       │ Do other work   │◄────┐
│   Send byte     │      │       │ (CPU is free!)  │     │
└────────┬────────┘      │       └────────┬────────┘     │
         │               │                │              │
         ▼               │                ▼              │
    More data? ──────────┘       ┌─────────────────┐     │
         │ No                    │  IRQ triggers   │     │
         ▼                       │  when TXE set   │     │
┌─────────────────┐              └────────┬────────┘     │
│      Done       │                       │              │
└─────────────────┘                       ▼              │
                                 ┌─────────────────┐     │
                                 │ ISR: Send byte  │     │
                                 └────────┬────────┘     │
                                          │              │
                                     More data? ─────────┘
                                          │ No
                                          ▼
                                 ┌─────────────────┐
                                 │      Done       │
                                 └─────────────────┘
```

### I2C Application States

```c
#define I2C_READY           0
#define I2C_BUSY_IN_RX      1
#define I2C_BUSY_IN_TX      2
```

### Interrupt-Driven Master Send

```c
uint8_t I2C_MasterSendDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer,
                              uint32_t Len, uint8_t SlaveAddr, uint8_t Sr)
{
    uint8_t busystate = pI2CHandle->TxRxState;
    
    if((busystate != I2C_BUSY_IN_TX) && (busystate != I2C_BUSY_IN_RX))
    {
        // Store parameters in handle
        pI2CHandle->pTxBuffer = pTxBuffer;
        pI2CHandle->TxLen = Len;
        pI2CHandle->TxRxState = I2C_BUSY_IN_TX;
        pI2CHandle->DevAddr = SlaveAddr;
        pI2CHandle->Sr = Sr;
        
        // Generate START condition
        I2C_GenerateStartCondition(pI2CHandle->pI2Cx);
        
        // Enable interrupts
        pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITBUFEN);  // Buffer interrupt
        pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITEVTEN);  // Event interrupt
        pI2CHandle->pI2Cx->CR2 |= (1 << I2C_CR2_ITERREN);  // Error interrupt
    }
    
    return busystate;
}
```

### Event Interrupt Handler

```c
void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle)
{
    uint32_t temp1, temp2, temp3;
    
    temp1 = pI2CHandle->pI2Cx->CR2 & (1 << I2C_CR2_ITEVTEN);
    temp2 = pI2CHandle->pI2Cx->CR2 & (1 << I2C_CR2_ITBUFEN);
    
    // 1. Handle SB (Start Bit) event - Master mode only
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_SB);
    if(temp1 && temp3)
    {
        // Start condition generated - send address
        if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
        {
            I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
        }
        else if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
        {
            I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx, pI2CHandle->DevAddr);
        }
    }
    
    // 2. Handle ADDR event
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_ADDR);
    if(temp1 && temp3)
    {
        // Address phase complete - clear ADDR flag
        I2C_ClearADDRFlag(pI2CHandle);
    }
    
    // 3. Handle BTF (Byte Transfer Finished) event
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_BTF);
    if(temp1 && temp3)
    {
        if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
        {
            // Make sure TXE is also set
            if(pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_TXE))
            {
                // BTF=1, TXE=1 means transmission complete
                if(pI2CHandle->TxLen == 0)
                {
                    // Generate STOP if not repeated start
                    if(pI2CHandle->Sr == I2C_DISABLE_SR)
                    {
                        I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
                    }
                    
                    // Close transmission
                    I2C_CloseSendData(pI2CHandle);
                    
                    // Notify application
                    I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_TX_CMPLT);
                }
            }
        }
    }
    
    // 4. Handle STOPF event - Slave mode only
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_STOPF);
    if(temp1 && temp3)
    {
        // Clear STOPF: read SR1, write to CR1
        pI2CHandle->pI2Cx->CR1 |= 0x0000;
        
        // Notify application
        I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_STOP);
    }
    
    // 5. Handle TXE event
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_TXE);
    if(temp1 && temp2 && temp3)
    {
        // Check if master mode
        if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
        {
            if(pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
            {
                if(pI2CHandle->TxLen > 0)
                {
                    // Send data
                    pI2CHandle->pI2Cx->DR = *(pI2CHandle->pTxBuffer);
                    pI2CHandle->TxLen--;
                    pI2CHandle->pTxBuffer++;
                }
            }
        }
        else
        {
            // Slave mode - notify application
            if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA))
            {
                I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_REQ);
            }
        }
    }
    
    // 6. Handle RXNE event
    temp3 = pI2CHandle->pI2Cx->SR1 & (1 << I2C_SR1_RXNE);
    if(temp1 && temp2 && temp3)
    {
        if(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_MSL))
        {
            // Master mode
            if(pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
            {
                I2C_MasterHandleRXNEInterrupt(pI2CHandle);
            }
        }
        else
        {
            // Slave mode
            if(!(pI2CHandle->pI2Cx->SR2 & (1 << I2C_SR2_TRA)))
            {
                I2C_ApplicationEventCallback(pI2CHandle, I2C_EV_DATA_RCV);
            }
        }
    }
}
```

---

## 9. Error Handling

### I2C Errors

```
┌────────────────┬────────────────────────────────────────────────┐
│     Error      │              Description                       │
├────────────────┼────────────────────────────────────────────────┤
│ BERR           │ Bus Error - Misplaced START or STOP condition  │
│                │ (SDA changed while SCL was HIGH)               │
├────────────────┼────────────────────────────────────────────────┤
│ ARLO           │ Arbitration Lost - Another master took control │
│                │ (Multi-master only)                            │
├────────────────┼────────────────────────────────────────────────┤
│ AF             │ Acknowledge Failure - No ACK received          │
│                │ (Device not responding or wrong address)       │
├────────────────┼────────────────────────────────────────────────┤
│ OVR            │ Overrun/Underrun - Data lost                   │
│                │ (Clock stretching disabled, data too fast)     │
├────────────────┼────────────────────────────────────────────────┤
│ TIMEOUT        │ SCL held LOW too long by slave                 │
│                │ (Slave hung or communication issue)            │
└────────────────┴────────────────────────────────────────────────┘
```

### Error Interrupt Handler

```c
void I2C_ER_IRQHandling(I2C_Handle_t *pI2CHandle)
{
    uint32_t temp1, temp2;
    
    temp2 = (pI2CHandle->pI2Cx->CR2) & (1 << I2C_CR2_ITERREN);
    
    // 1. Bus Error
    temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_BERR);
    if(temp1 && temp2)
    {
        // Clear error flag
        pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_BERR);
        
        // Notify application
        I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_BERR);
    }
    
    // 2. Arbitration Lost
    temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_ARLO);
    if(temp1 && temp2)
    {
        pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_ARLO);
        I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_ARLO);
    }
    
    // 3. ACK Failure
    temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_AF);
    if(temp1 && temp2)
    {
        pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_AF);
        I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_AF);
    }
    
    // 4. Overrun/Underrun
    temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_OVR);
    if(temp1 && temp2)
    {
        pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_OVR);
        I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_OVR);
    }
    
    // 5. Timeout
    temp1 = (pI2CHandle->pI2Cx->SR1) & (1 << I2C_SR1_TIMEOUT);
    if(temp1 && temp2)
    {
        pI2CHandle->pI2Cx->SR1 &= ~(1 << I2C_SR1_TIMEOUT);
        I2C_ApplicationEventCallback(pI2CHandle, I2C_ERROR_TIMEOUT);
    }
}
```

---

## 10. Testing Your Driver

### Test Setup

```
Hardware Connection:
                    ┌───────────────┐
                    │  STM32F446RE  │
                    │               │
    ┌───────────────┤ PB6 (I2C1_SCL)├───────────┬───────┐
    │               │               │           │       │
    │  ┌────────────┤ PB7 (I2C1_SDA)├───────┬───┼───┐   │
    │  │            │               │       │   │   │   │
    │  │            │      GND      ├───┬───┼───┼───┼───┤
    │  │            └───────────────┘   │   │   │   │   │
    │  │                                │   │   │   │   │
    │  │       ┌────────────────────────┘   │   │   │   │
    │  │       │   ┌────────────────────────┘   │   │   │
    │  │       │   │   ┌────────────────────────┘   │   │
    │  │       │   │   │                            │   │
    │  │       │   │   │   ┌─────────────────┐      │   │
    │  │       │   │   │   │  I2C Device     │     [Rp] [Rp]
    │  │       │   │   │   │  (e.g., EEPROM) │      │   │
    │  │       │   │   └───┤ SCL             ├──────┘   │
    │  │       │   │       │                 │          │
    │  │       │   └───────┤ SDA             ├──────────┘
    │  │       │           │                 │
    │  │       └───────────┤ GND             │
    │  │                   │                 │
    │  │                   │ Addr: 0x50      │
    │  │                   └─────────────────┘
    │  │
   VCC VCC
   (External or from board)
   
   Rp = Pull-up resistor (4.7kΩ typical)
```

### Test Application - Scan I2C Bus

```c
#include "stm32f446xx.h"
#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_i2c_driver.h"

I2C_Handle_t I2C1Handle;

void I2C1_GPIOInit(void)
{
    GPIO_Handle_t I2CPins;
    
    I2CPins.pGPIOx = GPIOB;
    I2CPins.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
    I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;  // Open-drain!
    I2CPins.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
    I2CPins.GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C
    I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_FAST;
    
    // SCL - PB6
    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_6;
    GPIO_Init(&I2CPins);
    
    // SDA - PB7
    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_NO_7;
    GPIO_Init(&I2CPins);
}

void I2C1_Init(void)
{
    I2C1Handle.pI2Cx = I2C1;
    I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_SM;
    I2C1Handle.I2C_Config.I2C_DeviceAddress = 0x61;  // Own address
    I2C1Handle.I2C_Config.I2C_AckControl = I2C_ACK_ENABLE;
    I2C1Handle.I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
    
    I2C_Init(&I2C1Handle);
}

// Scan all possible I2C addresses
void I2C_ScanBus(void)
{
    uint8_t dummy = 0;
    
    printf("Scanning I2C bus...\n");
    printf("     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
    
    for(uint8_t addr = 0; addr < 128; addr++)
    {
        if(addr % 16 == 0)
        {
            printf("%02X: ", addr);
        }
        
        // Skip reserved addresses
        if(addr < 8 || addr > 119)
        {
            printf("   ");
        }
        else
        {
            // Try to communicate
            I2C_GenerateStartCondition(I2C1);
            while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_SB));
            
            I2C_ExecuteAddressPhaseWrite(I2C1, addr);
            
            // Wait a bit for response
            uint32_t timeout = 10000;
            while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR) && timeout--);
            
            if(I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
            {
                // Device found!
                printf("%02X ", addr);
                I2C_ClearADDRFlag(&I2C1Handle);
            }
            else
            {
                // Check for AF (no ACK)
                if(I2C_GetFlagStatus(I2C1, I2C_FLAG_AF))
                {
                    I2C1->SR1 &= ~(1 << I2C_SR1_AF);
                    printf("-- ");
                }
                else
                {
                    printf("?? ");
                }
            }
            
            I2C_GenerateStopCondition(I2C1);
            
            // Small delay
            for(volatile int i = 0; i < 1000; i++);
        }
        
        if((addr + 1) % 16 == 0)
        {
            printf("\n");
        }
    }
}

int main(void)
{
    // Initialize GPIO for I2C
    I2C1_GPIOInit();
    
    // Initialize I2C peripheral
    I2C1_Init();
    
    // Enable I2C peripheral
    I2C_PeripheralControl(I2C1, ENABLE);
    
    // Scan for devices
    I2C_ScanBus();
    
    while(1);
}
```

### Test Application - Read from Sensor

```c
#define TEMP_SENSOR_ADDR    0x48    // Example: LM75 temperature sensor
#define TEMP_REG            0x00    // Temperature register

void Read_Temperature(void)
{
    uint8_t reg_addr = TEMP_REG;
    uint8_t temp_data[2];
    
    // Write register address
    I2C_MasterSendData(&I2C1Handle, &reg_addr, 1, TEMP_SENSOR_ADDR, I2C_ENABLE_SR);
    
    // Read temperature (2 bytes)
    I2C_MasterReceiveData(&I2C1Handle, temp_data, 2, TEMP_SENSOR_ADDR, I2C_DISABLE_SR);
    
    // Convert to temperature
    int16_t temp_raw = (temp_data[0] << 8) | temp_data[1];
    float temperature = (float)(temp_raw >> 5) * 0.125;
    
    printf("Temperature: %.2f°C\n", temperature);
}
```

---

## 11. Best Practices

### 1. Always Use Pull-up Resistors

```
Rule of thumb for pull-up resistor values:
- Standard mode (100kHz): 4.7kΩ to 10kΩ
- Fast mode (400kHz): 1kΩ to 4.7kΩ
- Depends on bus capacitance and number of devices
```

### 2. Configure GPIO Correctly

```c
// I2C pins MUST be:
// - Open-drain (GPIO_OP_TYPE_OD)
// - With pull-ups (GPIO_PIN_PU or external resistors)
// - Alternate function (AF4 for I2C on STM32F4)

GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;  // CRITICAL!
GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
GPIO_PinConfig.GPIO_PinAltFunMode = 4;  // AF4 for I2C
```

### 3. Handle Errors Properly

```c
__weak void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv)
{
    switch(AppEv)
    {
        case I2C_EV_TX_CMPLT:
            // Transmission complete
            break;
        case I2C_EV_RX_CMPLT:
            // Reception complete
            break;
        case I2C_ERROR_AF:
            // No ACK - device not responding
            I2C_GenerateStopCondition(pI2CHandle->pI2Cx);
            I2C_CloseSendData(pI2CHandle);
            break;
        case I2C_ERROR_BERR:
            // Bus error - recover
            I2C_PeripheralControl(pI2CHandle->pI2Cx, DISABLE);
            I2C_PeripheralControl(pI2CHandle->pI2Cx, ENABLE);
            break;
    }
}
```

### 4. Use Timeouts

```c
uint32_t timeout = 100000;
while(!I2C_GetFlagStatus(pI2Cx, I2C_FLAG_SB))
{
    if(--timeout == 0)
    {
        // Handle timeout - bus might be stuck
        return I2C_ERROR_TIMEOUT;
    }
}
```

### 5. Recover from Bus Lock

```c
void I2C_BusRecovery(GPIO_TypeDef *GPIOx, uint8_t SCL_Pin, uint8_t SDA_Pin)
{
    // Temporarily configure as GPIO
    // Toggle SCL 9 times to release SDA
    for(int i = 0; i < 9; i++)
    {
        GPIO_WriteToOutputPin(GPIOx, SCL_Pin, 0);
        delay_us(10);
        GPIO_WriteToOutputPin(GPIOx, SCL_Pin, 1);
        delay_us(10);
    }
    
    // Generate STOP condition manually
    GPIO_WriteToOutputPin(GPIOx, SDA_Pin, 0);
    delay_us(10);
    GPIO_WriteToOutputPin(GPIOx, SCL_Pin, 1);
    delay_us(10);
    GPIO_WriteToOutputPin(GPIOx, SDA_Pin, 1);
    
    // Reconfigure as I2C
}
```

---

## 12. Troubleshooting

### Common Problems and Solutions

```
┌────────────────────────────────────────────────────────────────────┐
│ Problem: No communication at all                                   │
├────────────────────────────────────────────────────────────────────┤
│ Check:                                                             │
│ ✓ Pull-up resistors present and correct value                     │
│ ✓ Wiring is correct (SDA to SDA, SCL to SCL, GND connected)       │
│ ✓ Peripheral clock is enabled                                      │
│ ✓ GPIO pins configured as open-drain, alternate function          │
│ ✓ I2C peripheral enabled (PE bit set)                             │
│ ✓ Slave device is powered                                         │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│ Problem: Getting NACK (AF flag set)                                │
├────────────────────────────────────────────────────────────────────┤
│ Check:                                                             │
│ ✓ Slave address is correct (7-bit, not shifted)                   │
│ ✓ Slave is powered and ready                                       │
│ ✓ Clock speed is within slave's capability                        │
│ ✓ Some devices need time after power-on (add delay)               │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│ Problem: Bus stuck (BUSY flag always set)                          │
├────────────────────────────────────────────────────────────────────┤
│ Check:                                                             │
│ ✓ Generate clock pulses manually to release bus                   │
│ ✓ Reset I2C peripheral                                             │
│ ✓ Check for short circuits                                         │
│ ✓ Slave might be holding SDA low - clock recovery needed          │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│ Problem: Data corruption                                           │
├────────────────────────────────────────────────────────────────────┤
│ Check:                                                             │
│ ✓ Clock speed might be too high for wire length                   │
│ ✓ Pull-up resistors might be wrong value                          │
│ ✓ Noise on the lines - add filtering capacitors                   │
│ ✓ Wire length too long (max ~1m for 100kHz)                       │
└────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────┐
│ Problem: Works sometimes, fails randomly                           │
├────────────────────────────────────────────────────────────────────┤
│ Check:                                                             │
│ ✓ Timing issues - add delays between operations                   │
│ ✓ Power supply stability                                           │
│ ✓ Interrupt priorities if using interrupts                        │
│ ✓ Check for race conditions in interrupt handlers                 │
└────────────────────────────────────────────────────────────────────┘
```

### Debugging with Logic Analyzer

```
What to look for on SDA and SCL:

Good Transaction:
   START  ADDRESS+W  ACK   DATA    ACK   STOP
      ↓       ↓       ↓      ↓      ↓      ↓
SDA ─┐_____╱‾‾‾‾‾‾╲___╱╲___╱‾‾‾‾‾╲___╱╲____╱‾
SCL ─────╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱╲_╱─
           1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9

No ACK (NACK):
   START  ADDRESS+W  NACK
      ↓       ↓       ↓
SDA ─┐_____╱‾‾‾‾‾‾╲___‾‾‾ (SDA stays HIGH - no pull down)
SCL ─────╲_╱╲_╱╲_╱╲_╱╲_╱─
           1 2 3 4 5 6 7 8 9
                           └── No ACK: slave didn't respond
```

---

## Summary

### I2C Driver Development Checklist

```
□ 1. Understand I2C Protocol
     □ Two-wire interface (SDA, SCL)
     □ START/STOP conditions
     □ Addressing (7-bit or 10-bit)
     □ ACK/NACK mechanism

□ 2. Configure MCU Header
     □ I2C register definitions
     □ Base addresses
     □ Bit position macros

□ 3. Create Driver Header
     □ Configuration structure
     □ Handle structure
     □ Macros for speeds, modes
     □ API function prototypes

□ 4. Implement Driver Functions
     □ Clock control
     □ Initialization (CCR, TRISE calculation)
     □ Master send/receive (blocking)
     □ Master send/receive (interrupt)
     □ Slave send/receive (optional)
     □ Error handling

□ 5. Test Thoroughly
     □ Bus scan
     □ Read/Write to known device
     □ Error recovery
     □ Different speeds

□ 6. Document
     □ Usage examples
     □ Hardware connections
     □ Known issues
```

### Quick Reference - I2C APIs

```c
// Initialization
void I2C_PeriClockControl(I2C_RegDef_t *pI2Cx, uint8_t EnorDi);
void I2C_Init(I2C_Handle_t *pI2CHandle);
void I2C_DeInit(I2C_RegDef_t *pI2Cx);

// Master Mode - Blocking
void I2C_MasterSendData(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, 
                        uint32_t Len, uint8_t SlaveAddr, uint8_t Sr);
void I2C_MasterReceiveData(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, 
                           uint8_t Len, uint8_t SlaveAddr, uint8_t Sr);

// Master Mode - Interrupt
uint8_t I2C_MasterSendDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pTxBuffer, 
                             uint32_t Len, uint8_t SlaveAddr, uint8_t Sr);
uint8_t I2C_MasterReceiveDataIT(I2C_Handle_t *pI2CHandle, uint8_t *pRxBuffer, 
                                uint8_t Len, uint8_t SlaveAddr, uint8_t Sr);

// Slave Mode
void I2C_SlaveSendData(I2C_RegDef_t *pI2C, uint8_t data);
uint8_t I2C_SlaveReceiveData(I2C_RegDef_t *pI2C);

// Control Functions
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi);
void I2C_ManageAcking(I2C_RegDef_t *pI2Cx, uint8_t EnorDi);
void I2C_GenerateStopCondition(I2C_RegDef_t *pI2Cx);

// Interrupt Handling
void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi);
void I2C_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority);
void I2C_EV_IRQHandling(I2C_Handle_t *pI2CHandle);
void I2C_ER_IRQHandling(I2C_Handle_t *pI2CHandle);

// Status and Callback
uint8_t I2C_GetFlagStatus(I2C_RegDef_t *pI2Cx, uint32_t FlagName);
void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv);
```

---

**Congratulations!** You now have a complete understanding of I2C driver development. With this knowledge, you can:

1. ✅ Understand the I2C protocol thoroughly
2. ✅ Read and interpret I2C waveforms
3. ✅ Configure STM32F446RE I2C peripherals
4. ✅ Write master and slave I2C drivers
5. ✅ Implement both blocking and interrupt-driven communication
6. ✅ Handle errors and recover from bus issues
7. ✅ Debug I2C communication problems

**Next Steps:**
- Try communicating with an actual I2C device (EEPROM, sensor, RTC)
- Implement DMA-based I2C for higher efficiency
- Explore the FMPI2C peripheral for 1MHz operation
- Study the I2C specification for advanced features (10-bit addressing, clock stretching)

